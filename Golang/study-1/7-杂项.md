# 杂项

[toc]

## 1 module

.mod

### 1.1

```bash
# 将项目中的包升级到最新的次版本或修订版本
go get -u

# 将项目中的包升级到最新的修订版本
go get -u=patch

# 下载或升级到指定版本
go get [包名]@[版本号]
```

### 1.2 go.mod 命令

```text
module  指定包的名字，路径

require 指定依赖项

replace 可以替换的依赖项
replace gplang.org/x/crypto v0.0.0 => github.com/golang/crypto v0.0.0

exclude 可以忽略的依赖项
```

## 2 package

### 2.1 标准引用

```go
import "fmt"

import (
    "aaa"
    "bbb"
)
```

### 2.2 自定义别名引用格式

```go
import F "fmt"
```

### 2.3 省略引用格式

相当于把 fmt 包合并至当前程序，在使用fmt 包内的方法时不用加前缀 `fmt`

```go
import . "fmt"
```

### 2.4 匿名引用格式

在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时
可以使用匿名引用格式

```go
import _ "fmt"
```

## 3 跨平台交叉编译

- CGO_ENABLED
  - 0 关闭 CGO
  - 1 打开 CGO 默认
- GOOS
  - linux
  - windows
  - darwin
- GOARCH
  - amd64
  - arm64

```bash
go tool dist list

# 交叉编译需要禁用 CGO
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build

CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags '-s -w --extldflags "-static -fpic"' main.go
# -ldflags
# -s -w 去掉调试信息，减小构建后文件体积
# --extldflags "-static -fpic" 完全静态编译

```

## 4 关键字

### 4.1 make new

- make 初始化 slice切片，map映射，channel通道，已经是引用，返回自身
- new 根据传入的类型分配一块内存空间，**并返回指针**

```go
slice := make([]int, 0, 100)
map := make(map[string]int)
channel := make(chan int, 5)

age := new(uint8)

var age uint8
a := &age
```

### 4.2 defer

延迟调用，先进后出，先注册，后执行，用于资源回收

defer function

os.Exit() 后 defer 不再被执行

### 4.3 panic recover

处理运行时错误，recover 捕获由 panic 抛出的错误

#### 4.3.1 panic

发生 panic 后，从 panic 处立即返回，
逐层向上执行函数的 defer 语句，
然后逐层打印函数调用堆栈，直至被 recover 捕获或运行到最外层而退出

#### 4.3.2 recover

recover 捕获 panic，阻止 panic 继续向上传递。
recover 需要存在 defer 后的函数体中，被直接调用才能捕获异常

由于 init 函数先于 main 执行，所以 init 函数中的 panic 只能在 init 中捕获

函数并不能捕获内部新启动的 goroutine 所抛出的 panic

## 5 打印

```go
func main(){
    // 10, 2, 8, 16 进制

    age := 15

    fmt.Printf("%d\n", age)
    fmt.Printf("%b\n", age)
    fmt.Printf("%o\n", age)
    fmt.Printf("%x\n", age)

    name := "pandora"

    // %T type
    fmt.Printf("%T\n", name)

    // %v value
    fmt.Printf("%v\n", name)

    // "pandora"
    fmt.Printf("%#v\n", name)

    // %s 字符串
    fmt.Printf("%s\n", name)

    // %c 输出单个字符
    fmt.Printf("$c\n", 'a')

    // %u 无符号十进制数

    // %p 指针

    // %f 浮点数
}
```

## 6 JSON

struct 与 JSON 序列化，反序列化

json.Marshal()

json.Unmarshal()

### 6.1 example

```go
type Person struct {
    Title   string
    Age     uint8
}

func main() {

    c := &Person{
        Title:  "101",
        Age:    12,
    }

    data, err := json.Marshal(c)
    fmt.Printf("json: %s\n", data)

    str := `{"Title": "101", "Age": 12}`

    c1 := &Person{}

    err = json.Unmarshal([]byte(str), c1)
}
```

### 6.2 Tag

Tag 是结构体元信息，可以在运行时通过反射机制读取

`key1:"value1" key2:"value2"`

```go
package main

import (
    "encoding/json"
    "fmt"
)

type student struct {
    Name    string `json:"name"`   // 通过指定 tag 实现 JSON 序列化该字段时的 key，反序列化时，可以接受 Name,name
    Gender  string                 // json 序列化默认使用字段名称作为 key，只接受 Gender
    age     int                    // 私有 不能被 json 包访问，不能序列化和反序列化
}

func main() {

    s1 := student{
        Name: "pandora",
        Gender: "A",
        age: 12,
    }

    _, err := json.Marshal(s1)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(s1.Name, s1.age)
    }

    s2 := &student{}

    str := `{"name": "athena", "Gender": "B", "age": 12}`
    err = json.Unmarshal([]byte(str), s2)

    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Printf("%v %T\n", s2, s2)
        fmt.Println(s2.Name, s2.age)
    }
}

```
