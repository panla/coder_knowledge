# 类型系统

[toc]

## 0

```text
语言特性设计尽可能正交，相互之间不要关联，对多态的支持有接口处理

预声明类型/简单类型、自定义类型，复合类型
面向对象：
    struct 取代 class
    接口处理多态
类型系统分为：
    命名类型，非命名类型，底层类型，动态类型，静态类型等
自定义类型，类型方法
```

## 1 类型简介

命名类型，未命名类型

两个类型相同的判断条件

类型之间的可赋值型

使用 type 定义的新类型 不会继承原有类型的方法

### 1.1 命名类型，未命名类型

- 命名类型：可以通过标识符来表示（包括基本类型中的预声明简单类型，用户自定义类型）
  - 命名类型 = 预声明简单类型/简单类型 + 用户自定义类型
  - 预声明简单类型
  - 用户自定义类型 type 关键字
- 未命名类型：由预声明类型、关键字和操作符组合而成。（又称类型字面量）
  - 基本类型中的复合数据类型均属类型字面量
  - (array, slice, map, channel, pointer, function, struct, interface)
  - 复合数据类型 = 类型字面量 = 未命名类型

使用 type 声明的 struct 和 interface 是命名类型，没有使用 type 的是未命名类型

### 1.2 底层类型

底层类型的规则：

- 预声明类型和复合类型的底层类型是自身
- 自定义类型 `type new old` 中的 `new` 的底层类型逐层向下查找，直到查到 `old` 是 `预声明类型或复合类型` 为止

用于用到 类型赋值和类型强制转换

```go
type T1 string
type T2 T1
// string

type T3 []string
type T4 T3
// []string

type T5 []T1
type T6 T5
// []T1

```

### 1.3 类型相同，类型赋值

#### 1.3.1 判断类型相同

- 1，两个命名类型相同需要: 两个类型声明的语句完全相同
- 2，两个未命名类型相同需要: 类型声明字面量的结构相同，且内部元素的类型相同
- 3，命名类型和未命名类型: 永不相同
- 4，通过类型别名语句声明的两个类型: 相同
  - 兼容
  - 按包隔离

类型为 A 的变量 a 可以赋值给类型为 B，就称为类型 A 可以赋值给类型 B

#### 1.3.2 类型赋值需要满足其中一个

```text
1，A 和 B 的类型相同
2，A 和 B 的底层类型相同，且 A 和 B 至少有一个是未命名类型(符合数据类型)
3，A 是接口类型，B 是具体类型，A 方法集是 B 方法集的超集，大的赋值给小的
4，A 和 B 是通道类型，元素类型相同，且至少有一个是未命名类型(符合数据类型)
5，a 是 nil，B 是复合数据类型
6，a 是一个字面常量值，可以表示 T 的值(B 的值???) # FIXME
```

TODO

```go
type Map map[string]string
type iMap Map
// iMap 仍可 range 遍历

mp := make(map[string]string, 10)
mp["name"] = "pandora"

// mp 和 Map 有相同的底层类型 map[string]stirng，并且 mp 是未命名类型-map
// 可以赋值
var ma Map = mp
```

### 1.4 类型强制转换

```text
var t T = (T) (x)

非常量类型的变量 x 可以强制转化并传递给类型 T 需要满足其一
1，x 可以直接赋值给 T 类型变量
2，x 的类型和 T 具有相同的底层类型
3，x 的类型和 T 都是未命名的指针类型，并且指针指向的类型具有相同的底层类型
4，x 的类型和 T 都是整型 或 都是浮点型 或 都是 复数类型 (属于 2 的一种)
5，x 是整数值或 []byte 类型的值，T 是 string 类型
6，x 是一个字符串，T 是 []byte 或 []rune 类型
7，数值与字符串的转换---strconv
```

## 2 类型方法

为类型增加方法

### 2.1 自定义类型

```text
定义自定义类型
type new old

old: 自定义类型，预声明类型，未命名类型
new: 新类型标识符，与 old 底层类型相同，继承了底层类型的操作集合
```

#### 2.1.1 定义和初始化

```go
// 使用 type 自定义的 struct 类型属于 用户自定义类型 属于 命名类型
type Person struct{
    name string
    age int8
}

// 使用字面量表示的 struct 属于未命名类型
struct {
    name string
    age int8
}

// 非 命名类型空结构
var s = struct{}{}

// 按照字段顺序进行初始化
pa := Person{"pandora", 14}

// 指定字段名进行初始化 **建议**
pb := Person{name: "pandora", age: 14}

// 使用 new 初始化，获取指向 struct 的指针
pc := new(Person)

// 一次一个字段
pd := Person{}
pd.name = "pandora"
pd.age = 14

// 使用构造函数初始化
```

#### 2.1.2 struct 字段特点

- 字段可以是任意的类型
- 字段的类型名需要唯一(????? 字段名唯一??????)
- 匿名字段
  - 只有字段类型，没有字段名
  - 字段是 命名类型或命名类型的指针

```go
type Element struct {
    // 指向自身类型的指针
    next, prev *Element
    list *List
    Value interface{}
}
```

#### 2.1.3 自定义接口类型

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

### 2.2 方法

特点

```text
1，可以为命名类型增加方法(除了接口)，非命名类型不能自定义方法
2，限制：
    2.1 必须在一个包里
    2.2 不能为预声明类型增加方法
3，方法的命名空间的可见性和变量一样
4，新类型不能调用原有类型的方法，底层类型的运算可被继承
```

定义

```text
Go 语言的类型方法是一种对类型行为的封装，
方法：特殊类型的函数
    显式地将对象实例或指针作为第一个参数---方法的接收者

func (t TypeName)MethodName(ParamList)(Returnlist) {
    //
}
-> 改写为常规函数
func TypeName_MethodName(t TypeName, otherParamList)(ReturnList){
    //
}

func (t *TypeName)MethodName(ParamList)(Returnlist) {
    //
}
-> 改写为常规函数
func TypeName_MethodName(t *TypeName, otherParamList)(ReturnList){
    //
}
```

示例

```go
package main

import (
    "fmt"
)

// 定义自定义类型 SliceInt
type SliceInt []int

func (s SliceInt) Sum() int {
    sum := 0
    for _, i := range s {
        sum += i
    }
    return sum
}

// 与上面的方法等价
func SliceInt_Sum(s SliceInt) int {
    sum := 0
    for _, i := range s {
        sum += i
    }
    return sum
}

func main() {
    fmt.Println("Hello")

    var s SliceInt = []int{1, 2, 3, 4}

    // SliceInt 类型具有了 Sum 方法
    result := s.Sum()
    fmt.Println(result)

    result_2 := SliceInt_Sum(s)
    fmt.Println(result_2)
}

```

## 3 方法调用

调用方式，方法集，方法变量，方法表达式

### 3.1 一般调用，方法值调用，方法表达式调用

```text
一般调用
    t.Get()
    t 实例或指针

方法值
    是一个 函数类型变量，一个带有闭包的函数变量
    f := t.Get
    f()

方法表达式
    提供一种语法，将类型方法调用显式地转换为函数调用
    (T).Get(t)

    t2 = &t
    (*T).Get(t2)
```

```go
package main

import (
    "fmt"
)

type T struct {
    a int
}

func (t T) Get() int {
    // 获取值
    return t.a
}

func (t *T) PGet() int {
    // 获取值
    return t.a
}

func (t T) Set(v int) T {
    // 设置值
    t.a = v
    return t
}

func (t *T) PSet(v int) *T {
    // 设置值
    t.a = v
    return t
}

func main() {
    fmt.Println("Hello")

    var t = T{a: 10}
    var t2 = &t

    // 一般 实例调用
    t.PSet(30)
    fmt.Println(t.Get())
    fmt.Println(t.PGet())
    // 一般 指针调用
    t2.PSet(25)
    fmt.Println(t2.Get())
    fmt.Println(t2.PGet())

    // 方法值 实例调用
    f := t.Get
    fmt.Println(f())
    // 方法值 指针调用
    f2 := t2.Get
    fmt.Println(f2())

    // 方法表达式 实例调用
    fmt.Println((T).Get(t))
    // 方法表达式 指针调用
    fmt.Println((*T).Get(t2))
}

```

### 3.4 一般调用的方法集

```text
T 类型的方法集是 S, *T 类型的方法集是 S 和 *S
```

```text
在直接使用类型实例调用类型的方法时，无论值类型变量还是指针类型 ，都可以调用类型的所有方法，
原因是编译器在编译期间能够识别出这种调用关系，做了自动的转换。

自动转换
# TODO FIXME ?????????????????????
值传递的转为指针
指针传递的转为值
```

### 3.5 值调用和表达式调用的方法集

.............

```text
1，通过类型字面量显式地进行值调用和表达式调用，编译器不会做自动转换，会进行严格的方法集检查
2，通过类型变量进行值调用和表达式调用
    值调用方式调用时编译器会进行自动转换
    表达式调用时编译器不会进行转换，会进行严格的方法集检查

值调用
    通过类型字面量显式地调用时，不会
    通过类型变量进行调用时，会进行转换
方法表达式调用始终不进行转换
```

## 4 组合和方法集

struct：可以嵌入任意其他类型的字段，可以嵌套自身的指针类型的字段
内存分配按照字段顺序依次开辟连续的存储空间

### 4.1 组合

内嵌字段的初始化和访问 `.`，字段唯一时，不需全路径访问
内嵌字段的方法调用 `.`，使用简化模式访问时，同名方法中外层的方法能够覆盖内层的方法

### 4.2 组合的方法集

```text
对于匿名字段的方法集
若类型 S 包含 匿名字段 T，则 S 的方法集包含 T 的方法集
若类型 S 包含 匿名字段 *T，则 S 的方法集包含 T 和 *T 的方法集
*S 总是包含 T 和 *T 的方法集

类型实例传递给接口时，编译器不会进行自动转换，而是会进行严格的方法集校验。
```

## 5 函数类型

### 5.1 概念

```text
函数
    有名函数 `func FuncionName()`
        初始化一个函数字面量类型后将其赋值给一个函数名变量

    匿名函数 `func()`
        直接初始化一个函数字面量类型，只是没有绑定到一个具体变量上

函数类型
    函数字面量类型(未命名类型)，`func(InputTypeList)OutputTypeList`
        有名函数和匿名函数属于函数字面量类型的实例
        不能定义自己方法

        使用 type 声明一个有名函数类型，为其添加方法

    函数命名类型(命名类型)--函数类型
        `type NewFuncType FuncLiteral`
            NewFuncType 函数命名类型
            FuncLiteral 函数字面量类型 是 NewFuncType 的底层类型
        可以定义自己方法

函数签名，有名函数或匿名函数的字面量类型
    func (int, int) int

函数声明，函数名 + 函数签名
    函数签名 func (Input) Output
    函数声明 func FuncName(Input) Output
```

### 5.2 函数命名类型示例与注释

```go
package main

import (
    "fmt"
)

// 定义有名函数 add
// 函数名 add
// add 的函数签名是 func(int, int) int
// add 的字面量类型 func(int, int) int
// add 的类型是 函数字面量类型 func(int, int) int
// add 的函数声明与句 func add(int, int) int
func add(a, b int) int {
    return a + b
}

// 新定义函数类型 ADD
// ADD 底层类型是 函数字面量类型 func(int, int) int
type ADD func(int, int) int

func main() {
    // 定义匿名函数
    // 匿名函数不能独立存在，常作为函数参数、返回值，或者赋值给某个变量
    // 可以直接显式初始化
    // 匿名函数的类型是 函数字面量类型 func(int, int) int
    f := func(a, b int) int {
        return a + b
    }

    // add 和 ADD 的底层类型相同，并且 add 是字面量类型
    //所以 add 可直接赋值给 ADD 类型的变量 g
    var g ADD = add

    fmt.Println(g(1, 2))
    fmt.Println(f(1, 2))

    // 函数签名是 func(int, int) int
    fmt.Printf(f)
    fmt.Printf(add)
}

```

### 5.3 函数类型意义

```text
1，函数也是一种类型，可以在函数字面量类型的基础上定义一种命名函数类型
2，有名函数和匿名函数的函数签名与命名函数类型的底层类型相同，它们之间可以进行类型转换。
3，可以为有名函数类型添加方法，装饰设计
4，为有名函数类型添加方法
    使其与接口打通关系，使用接口的地方可以传递函数类型的变量，函数到接口的转换
```
