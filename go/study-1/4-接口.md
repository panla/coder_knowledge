# 接口

[toc]

```text
1，接口是一个编程规约，也是一组方法签名的集合
2，接口是没有具体实现辑的，也不能定义字段
3，一个具体类型实现接口不需要在语法上显式地声明，只要具体类型的方法集是接口方法集的超集，就代表该类型实现了接口
```

```text
实例变量：变量值，变量类型，方法
接口变量：变量值，变量类型
空接口：
```

## 1 基本概念

### 1.1 接口声明

```go
// 接口字面量类型
interface {
    Read(p []byte) {n int, err error}
    Write(p []byte) {n int, err error}
}

// 接口命名类型
type Reader interface {
    // 接口命名类型，内含 方法声明
    Read(p []byte) {n int, err error}
}

type Writer interface {
    Write(p []byte) {n int, err error}
}

// 混合
type ReaderWriter interface {
    // 接口类型匿名字段(接口内嵌入其他接口)
    Reader

    // 方法声明=方法名+方法签名
    Write(p []byte) {n int, err error}
}
```

### 1.2 接口初始化，接口方法调用，接口动态类型，静态类型

### 1.2.1 接口初始化

接口绑定具体类型的实例的过程称为接口初始化

要求赋值者的方法集是接口变量的方法集的超集
等号右边的方法集是左边接口变量的方法集的超集

```text
实例赋值接口变量
    如果实例的方法集是接口的方法集的超集，则该具体类型实现了接口，
    可以把该实例直接赋值给接口类型的变量
    初始化后，调用接口的方法就相当于调用接口绑定的具体类型的方法

接口变量赋值给接口变量
    已经初始化的接口类型变量 a 直接赋值给另一种接口变量 b，要求 b 的方法集是 a 的方法集的子集
```

#### 1.2.2 接口方法调用

接口方法调用的最终地址在运行期决定
用具体类型变量初始化后，会使用具体类型的方法指针初始化接口变量
间接地调用实例的方法，运行时调用

#### 1.2.2 接口动态类型，静态类型

接口绑定的具体实例的类型称为接口的动态类型
接口定义时，接口的类型为静态类型，是 接口的方法签名集合
大的赋值给小的，超集赋值给子集

## 2 接口运算

基于接口编程
类型断言
类型查询，检查运行时的接口类型

### 2.1 类型断言

```text
i.(TypeName)

i: 接口变量
TypeName:
    接口类型: 判断 i 绑定的实例类型是否实现了 TypeName 接口
    具体类型名: 判断判断 i 绑定的实例类型是否是 TypeName

o := i.(TypeName)
o 的类型是 TypeName
TypeName:
    接口类型名: o 底层绑定的具体类型实例是 i 绑定的实例值的副本
    具体类型名: o 的值是 i 绑定的实例值的副本
```

```go
// comma, ok 表达式
if o, ok := i.(TypeName); ok {

}
```

### 2.2 类型查询

```text
switch v := i.(TypeName) {
    case type_1:
        xxx
    case type_2:
        yyy
    default:
        zzz
}
```

#### 2.2.1 语义分析

```text
查询一个接口变量底层绑定的底层变量的具体类型是什么
查询一个接口变量绑定的底层变量是否还实现了其他接口

i 是接口类型变量
case 语句后，可以是 非接口类型名或接口类型名
    接口类型名：v 的类型是接口类型，v 底层绑定的具体类型实例是 i 绑定的实例值的副本
    具体类型名：v 是该具体类型变量，v 的值是 i 绑定的实例值的副本
```

### 2.3 接口优点，使用形式

解耦，在曾与层之间使用接口进行抽象和解耦
实现泛型，使用空接口作为函数或方法用在需要泛型的场景中

- struct 内嵌字段
- 其他接口内嵌字段
- 函数或方法形参
- 函数或方法返回值

## 3 空接口

### 3.1 概念

没有任何方法的接口 称为空接口 表示为 `interface {}`

作用

泛型，如果一个函数需要接收任意类型的参数，参数类型可以是**空接口**这是弥补没有泛型的一种手段
反射，空接口是反射实现的基础，反射库就是将相关具体的类型转换并赋值给空接口后才去处理

空接口和nil

接口有 类型和值
空接口有 实例类型和指向绑定实例的指针，两个都为 nil 时，空接口为 nil

## 4 接口内部实现

接口是 Go 语言实现多态和反射的基础。duck 型的接口完全解耦接口和具体实现者

### 4.1 数据结构

```go
// src/runtime/type.go 类型元信息通用结构
type _type struct {

}

// src/runtime/runtime2.go
type itab struct {
    inter *interfacetype  // 指向接口类型元信息的指针
    _type *_type          // 指向接口存放的具体实例的类型的元信息的指针
    hash uint32           // copy _type.hash
    fun [1]uintptr        // 函数指针
}

// 非空接口初始化的过程就是初始化 iface 类型的结构
type iface struct {
    tab *itab  // 存放 接口自身类型实例，绑定的实例类型，及实例相关的函数指针
    data unsafe.Pointer  // 数据指针，指向接口绑定的实例的副本
}

// 接口类型元信息的数据结构
```

### 4.2 接口调用过程

### 4.3 接口调用代价

接口实例化，接口的方法调用

### 4.4 空接口的数据结构

```go
// src/runtime/runtime2.go

type eface struct {
    _type *_type
    data unsafe.Pointer
}
```

## 5 example

### 5.1 接口

```go
package main

import (
 "fmt"
)

type AbstractBanker interface{
 Do() // 抽象的处理业务的接口
}

type SaveBanker struct {
 // AbstractBanker
}

func (sb *SaveBanker) Do() {
 fmt.Println("存款")
}

type TransferBanker struct {
 // AbstractBanker
}

func (tb *TransferBanker) Do() {
 fmt.Println("转账")
}

type PayBanker struct {
 // AbstractBanker
}

func (pb *PayBanker) Do(){
 fmt.Println("支付")
}

func BankerBusiness(banker AbstractBanker){
 banker.Do()
}

func main(){
 // 存款业务
 sb := &SaveBanker{}
 sb.Do()

 tb := &TransferBanker{}
 tb.Do()

 pb := &PayBanker{}
 pb.Do()

 BankerBusiness((&SaveBanker{}))
 BankerBusiness((&TransferBanker{}))
 BankerBusiness((&PayBanker{}))
}
```
