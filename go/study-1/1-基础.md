# 基础

[toc]

## 2 初识

package 定义 可执行程序的包名，通过包来管理命名空间 #TODO

func main 程序入口

## 3 词法单元

标识符，操作符，分隔符

### 3.1 关键字 标识符

```text
定义包名 package
导入包名 import
声明常量 const
声明变量 var
定义函数 func
延迟执行 defer
并发语法 go
函数返回 return
```

```text
定义结构类型 struct
定义接口类型 interface
声明或创建map map
声明或创建chan chan
```

```text
流程分支 if else
循环 for range break continue
switch select type case default fallthrough
goto
```

### 3.2 内置类型 标识符

```text
整型，浮点型，复数，字符，字符串，接口，布尔
```

### 3.2 内置函数 标识符

```text
make new len cap append copy delete panic recover close complex real image Print Println
```

### 3.3 常量与空白 标识符

```text
true, false
iota
nil
_
```

### 3.4 操作符

```text
算术运算符
    加 减 乘 除 取模 自增一 自减一
    + - * / % ++ --

关系运算符
    大于 大于等于 小于 小于等于 等于 不等于
    > >= < <= == !=

逻辑运算符
    逻辑与 逻辑或 逻辑非
    && || !

位运算
    位与 位或 位异或/位非 与非 位右移 位左移
    & | ^ &^ >> <<

    无符号的，左移低位用0填充，右移高位用0填充
    有符号的，左移~~，右移，符号位被拷贝来填充

    两值不同结果为真

赋值
    := = += -= *= /= %= &= |= ^= &^= >>= <<=

() {} []
```

## 4 变量和常量

高级语言通过**一个标识符来绑定一块特定的内存**，后续对特定内存的操作都可以使用该标识符来代替，
把对地址的操作和引用变为对变量的操作是编程领域的巨大进步

### 4.1 变量

使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时的类型决定，该内存地址存放的内容可变。

```go
// No.1
// 关键字 变量名称标识符 基本类型 初始值
// 如果无初始值，则初始化为类型的零值
// 声明后立即分配空间
var varName dataType [ = value]
var name string = "pandora"

// 类型推断
// vscode 飘红，但也能执行
var name = "pandora"

// No.2
// 先定义后赋值
var age uint8
age = 14

// No.3
// 短类型声明，只存在于函数内，此时自动进行类型推断
name := "pandora"

// No.4
age := uint8(15)

// No.5
// 匿名变量 _

// No.6 批量声明
var (
    name string
    age uint8
)
```

作用域

注意

```text
函数外的每个语句都需要以关键字开始
:= 不能在函数外
变量不能重复声明
_ 匿名变量
```

变量初始化错误

```text
多重赋值，重复声明。多个短变量声明和赋值中，至少有一个新声明的变量出现在左边
```

```text
# 无中间变量，交换变量
a = 100, b = 200

# 轮转
a = a + b // a = 300
b = a - b // b = 100
a = a - b // a = 200

# 按位异或
a = a ^ b
b = b ^ a
a = a ^ b

a, b = b, a
```

### 4.2 常量

使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时的类型决定，该内存地址存放的内容不可变。

分为 布尔型常量，字符型常量，数值型常量

预声明标识符 **iota** 用在常量声明中，其初始值为 0，一组多个常量同时声明时**其值逐行增加**。
自增的枚举变量，专门用来初始化常量。

```go
const (
    a0 = iota // ao = 0
    a1 = 100  // a1 = 100
    a2        // a2 = 100
    a3        // a3 = 100
)

const (
    b0, b1 = iota + 1, iota + 2 // 1, 2
    b2, b3 = iota + 1, iota + 2 // 2, 3
)

const (
    c0 = iota  // co = 0
    c1 = iota  // c1 = 1
    c2 = iota  // c2 = 2
)

const (
    d0 = iota  // d0 = 0
    d1         // d1 = 1
    d2         // d2 = 2
)
```

## 5 基本数据类型-预声明简单类型

tip **命名类型 = 简单类型 + 用户自定义类型**

### 5.1 整型

#### 5.1.1 无符号和有符号整型

```text
uintptr 无符号整型，存放指针
byte 是 uint8 的别名 ASCII 的一个字符
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64

0 ~~ 2^8 - 1
0 ~~ 2^16 - 1
0 ~~ 2^32 - 1
0 ~~ 2^64 - 1

-2^7 ~~ 2^7 - 1
-2^15 ~~ 2^15 - 1
-2^31 ~~ 2^31 - 1
-2^63 ~~ 2^63 - 1

32 位系统 int = int32 uint = uint32
64 位系统 int = int64 uint = uint64
```

### 5.2 浮点型和复数

```text
float32--24 float64

浮点数字面量被自动推断为 float64
应用 math 来比较

复数
complex64 complex128
```

### 5.3 布尔类型 bool

```text
true false
比较表达式和逻辑表达式的结果都是布尔类型数据

不能和整型转换
```

### 5.4 字符 rune 字节 byte

单引号为字符，双引号为字符串

rune 是 int32 的别名，byte 是 uint8 的别名

- rune int32 一个 UTF-8 字符
- byte uint8 一个 ASCII 编码的 一个字符 'A' 一个字节

一个 UTF-8 编码的 汉字 一般三个字节

```go
// 使用单引号表示一个字符
var ch byte = 'A'

// 在 ASCII 码表中，A 的值是 65
var ch byte = 65

// 65 十六进制 43
var ch byte = '\x41'

// 65 八进制 101
var ch byte = '\101'
```

### 5.5 字符串 string

```go
var name = "pandora"
// len = 7

address := "北京市"
// len = 9

var location string
location = "南京市"
// RuneCountInString = 4

var sn string = "123456"

// 转为字节数组
name_ := []byte(name)
// 转为Unicode的字符数组
address_ := []rune(address)
```

```go
// 字符串拼接

name := "pandora"
age := "17"

var stringBuilder bytes.Buffer
stringBuilder.WriteString(name)
stringBuilder.WriteString(age)
stringBuilder.String()
```

```text
1，字符串是常量，可以通过索引访问
2，字符串转为切片要慎用，每转换一次都会复制内容
3，字符串末尾不含 NULL 字符
4，字符串类型底层实现是一个二元的数据结构，一个是指针指向字节数组的起点，另一个是长度
5，基于字符串创建的切片和原字符串指向相同的底层字符数组，不能修改，对字符串的切片操作返回的仍是字符串
6，反引号 ` 原样输出
```

```go
import (
    "strings"
    "fmt"
)

func main(){
    name := "pandora|is|15|years|old"

    // 分割
    new_name := strings.Split(name, "|")
    fmt.Println(new_name)
    // new_name = [pandora is 15 years old]
    fmt.Printf("%T", new_name)
    // new_name 类型为 []string

    // 包含
    fmt.Println(strings.Contains(name, "p"))

    // 前缀，后缀
    fmt.Println(strings.HasPrefix(name, "p"))
    // true
    fmt.Println(strings.HasSuffix(name, "a"))
    // false

    // 查找序列。 正向，反向
    fmt.Println(strings.Index(name, "d"))
    fmt.Println(strings.LastIndex(name, "d"))

}
```

### 5.6 error

## 6 基本数据类型-复合数据类型

tip **复合数据类型 = 类型字面量 = 未命名类型**

指针(pointer)，数组(array)，切片(slice)，字典(map)，通道(channel)，结构(struct)，接口(interface)

### 6.1 指针

指针类型声明为 `*T` 引用类型
`*T` 出现在 = 左边表示**指针声明**，出现在 = 右边表示**取指针指向的值**

对变量取地址 &，对指针变量取值 *
指针变量的值是指针地址

new 用于简单类型 申请一块内存，返回 *T
make 只用于 slice map chan，返回类型本身

```go
var name = "pandora"
p := &name  // *p 和 name 的值都是 pandora

// 声明一个 int 类型的指针
var a *int

// name pandora
// &name 0xc00018a050
// p 0xc00018a050
// *p pandora
```

### 6.2 数组

```go
元素的类型与数组长度是数组类型的一部分

// no.1 声明
var names [3]string

// no.2 初始化 指定长度和初始化值
name := [3]{"pandora", "athena", "apolo"}

// no.3 初始化 不指定长度，指定初始化值，由初始化列表数量来推导确定长度
ages := [...]int8{12, 13, 14, 15}

// no.4 根据索引初始化
cars := [3]string{0: "宝马", 1: "奔驰", 2: "奥迪"}
```

- 创建完，确定长度，不可追加
- 数组是**值类型，值拷贝传递**
- 数组长度是数组类型的组成部分，[10]int [20]int 表示不同的类型。
- 可以根据数组创建切片

### 6.3 切片 slice

变长数组，数据结构中有指向数组的指针，**是引用类型**

三个元素：指向底层数组的指针、切片的元素数量和底层数组的容量

可以通过数组创建切片

```text
长度 len()
容量 cap()    指底层数组从 切片第一个元素 到 最后的元素 的数量
追加 append() 追加扩容，底层数组放不下时，会更换数组，需要用原先切片变量接收返回值
复制 copy()
无删除，可以一个个 append append(a1[:1], a1[2:]...)

array = [1, 3, 5]
slice = [1, 5]
array = [1, 5, 5] 把被删除元素后一个值复制到该位置
```

```go
// no.1 定义一个存放 string 类型元素的切片
var names []string  // 此时 namne = nil
// 初始化
names = []string{"pandora", "athena"}

// no.2 由数组得到切片
ages := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
ages_s = ages[: 3] // ages_c = [1, 2, 3]

// no.3 make
// 长度 10， 容量 10
ages := make([]int8, 10)

// 长度 10 容量 15，已有 10个元素占位， append 时是在后面
names := make([]string, 10, 15)
```

```go
ages := [...]{10, 11, 12, 13, 14, 15, 16, 17}
// [10 11 12 13 14 15 16 17]

ages_1 := ages[:]
// [10 11 12 13 14 15 16 17]

ages_2 := ages[1:5]
// [11 12 13 14]

ages_3 := ages[:5]
// [10 11 12 13 14]

ages_4 := ages[5:]
// [15 16 17]
```

字符串和切片

```go
names := "pandora"

names_1 := []byte(names)
names_2 := []rune(names)
```

### 6.4 map

`map[K]T` 是引用类型 **初始化后才能使用**

创建map

```go
// no.1 初始化
info := map[string]int{"a": 1, "b": 2}

// make(map[K]T)      容量使用默认值
// make(map[K]T, len) 使用指定长度

// no.2
var m1 map[string]int = make(map[string]int)
m1["age"] = 12

// no.3
m1 := make(map[string]int)
value, ok := m1["age"]

// no.4 元素为 map 的切片
var names = make([]map[int]string, 10, 10)
names[0] = make(map[int]string, 1)
names[0][2] = "长江"

// no.5 值为切片的 map
var name = make(map[string][]int, 10)
name["北京"] = []int{10, 20, 30}
```

内置操作

```text
map[k]

delete(map, k)
```

遍历

```go
m := make(map[string]int)
m["a"] = 12
m["b"] = 13

for k, v := range m {
    //
}
```

### 6.5 struct

结构类型，结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存
对 struct 取地址的操作，视为对该类型进行一次 new 的实例化操作

```go
type UserInfo struct {
    name string
    age int8
    address string
}
```

## 7 控制结构

### 7.1 if else

```go
age := 10
if age > 15 {
    //
} else {
    //
}
```

### 7.2 switch case

```go
grade := "A"
score := 90

switch score {
case 91:
    grade = "A"
case 80:
    grade = "B"
case 71, 72, 73:
    grade = "C"
    fallthrough
default: grade = "D"
}
```

### 7.3 迭代 for range

```go
for key, value := range "12345" {

}
```

for 循环

```go
// 1
for i := 0; i < 10; i++ {

}

// 2
i := 0
for ; i< 10; i++ {

}

// 3
i := 5
for i < 10 {
    i++
}

// 4 死循环
for {

}
```
