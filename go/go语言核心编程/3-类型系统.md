# 类型系统

[toc]

## 1 类型简介

命名类型，未命名类型，类型之间的可赋值型

使用 type 定义的新类型 不会继承原有类型的方法

### 1.1 命名类型，未命名类型

命名类型：可以通过标识符来表示（包括基本类型中的预声明简单类型，用户自定义类型）
命名类型=简单类型+用户自定义类型

未命名类型：由预声明类型、关键字和操作符组合而成（又称类型字面量）
复合数据类型(array, slice, map, channel, pointer, function, struct, interface)均属类型字面量
复合数据类型=类型字面量=未命名类型

### 1.2 底层类型

用于用到 类型赋值和类型强制转换

预声明类型和复合类型的底层类型是自身
自定义类型 `type new old` 中的 `new` 的底层类型逐层向下查找，直到查到 `old` 是 `预声明类型和复合类型` 为止

```go
type T1 string
type T2 T1
// string

type T3 []string
type T4 T3
// []string

type T5 []T1
type T6 T5
// []T1

```

### 1.3 类型相同，类型赋值

判断类型相同

```text
1，两个命名类型相同需要 两个类型声明的语句完全相同
2，命名类型和未命名类型永不相同
3，两个未命名类型相同需要 类型声明字面量的结构相同，且内部元素的类型相同
4，通过类型别名语句声明的两个类型相同
```

类型为 Tl 变量 可以赋值给类型为 T2 称为类型 Tl 可以赋值给类型 T2

类型赋值需要满足其一

```text
1，T1 和 T2 的类型相同
2，T1 和 T2 的底层类型相同，且至少有一个是未命名类型
3，T2 接口类型，T1 是具体类型，T1 方法集是 T2 方法集的超集
4，T1 和 T2 是通道类型，元素类型相同，且至少有一个是未命名类型
5，a 是 nil，T2 是 复合数据类型
6，a 是一个字面常量值，可以表示 T 的值，???(T2 的值) # FIXME
```

```go
type Map map[string]string
type iMap Map
// iMap 仍可 range 遍历
```

### 1.4 类型强制转换

```text
var a A = (B) (b)
非常量类型的变量 x 可以强制转化并传递给类型 T 需要满足其一
1，x 可以直接赋值给 T 类型变量
2，x 的类型和 T 具有相同的底层类型
3，x 的类型和 T 都是未命名的指针类型，并且指针指向的类型具有相同的底层类型
4，x 的类型和 T 都是整型 或 都是浮点型 或 都是 复数类型 (属于 2 的一种)
5，x 是整数值或 []byte 类型的值，T 是 string 类型
6，x 是一个字符串，T 是 []byte 或 []rune 类型
```

## 2 类型方法

### 2.1 自定义类型

```text
定义自定义类型
type new old

old: 自定义类型，预声明类型，未命名类型
new: 新类型标识符，与 old 底层类型相同，底层类型的操作集合
```

```go
// 使用 type 自定义的 struct 类型属于命名类型
type Person struct{
    name string
    age int8
}

// struct 字面量属于未命名类型
struct {
    name string
    age int8
}

// 按照字段顺序进行初始化
pa := Person{"pandora", 14}

// 指定宇段名进行初始化
pb := Person{name: "pandora", age: 14}

// 使用 new 初始化，获取指向 struct 的指针
pc := new(Person)

// 一次一个字段
pd := Person{}
pc.name = "pandora"
pc.age = 14

// 使用构造函数初始化
```

自定义接口类型

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

### 2.2 方法

特点

```text
1，可以为命名类型增加方法(除了接口)，非命名类型不能自定义方法
2，限制：
    2.1 必须在一个包里
    2.2 不能为预声明类型增加方法
3，方法的命名空间的可见性和变量一样
4，新类型不能调用原有类型的方法，底层运算可支持
```

定义

```text
Go 语言的类型方法是对类型行为的封装，(特殊类型的函数)，

func (t TypeName)MethodName(ParamList)(Returnlist) {
    //
}
-> 改写为常规函数
func TypeName_MethodName(t TypeName, otherParamList)(ReturnList){
    //
}

func (t *TypeName)MethodName(ParamList)(Returnlist) {
    //
}
-> 改写为常规函数
func TypeName_MethodName(t *TypeName, otherParamList)(ReturnList){
    //
}
```

示例

```go
package main

import (
    "fmt"
)

// 定义自定义类型 SliceInt
type SliceInt []int

func (s SliceInt) Sum() int {
    sum := 0
    for _, i := range s {
        sum += i
    }
    return sum
}

// 与上面的方法等价
func SliceInt_Sum(s SliceInt) int {
    sum := 0
    for _, i := range s {
        sum += i
    }
    return sum
}

func main() {
    fmt.Println("Hello")

    var s SliceInt = []int{1, 2, 3, 4}

    // SliceInt 类型具有了 Sum 方法
    result := s.Sum()
    fmt.Println(result)

    result_2 := SliceInt_Sum(s)
    fmt.Println(result_2)
}

```

## 3 方法调用

### 3.1 一般调用，方法值调用，方法表达式调用

```text
instance.MethodName(ParamList)
```

```go
package main

import (
    "fmt"
)

type T struct {
    a int
}

func (t T) Get() int {
    // 获取值
    return t.a
}

func (t *T) PSet(v int) int {
    // 通过指针设置值
    t.a = v
    return v
}

func main() {
    fmt.Println("Hello")

    var t = T{a: 10}
    var t2 = &t

    // 一般调用
    fmt.Println(t.Get())

    t2.PSet(25)
    fmt.Println(t.Get())

    // 方法值调用
    f := t.Get
    fmt.Println(f())

    // 方法表达式调用，似乎不能带调用指针的方法
    fmt.Println((T).Get(t))
}

```

### 3.4 方法集

```text
T 类型的方法集是 S, *T 类型的方法集是 和 *S
```

```text
在直接使用类型实例调用类型的方法时，无论值类型变量还是指
类型 ，都可以调用类型的所有方法，原因是编译器在编译期间能够识别出这种调用关系，
做了自动的转换。

# TODO
# FIXME
?????????????????????
值传递的转为指针
指针传递的转为值
```

### 3.5 值调用和表达式调用的方法集

.............

```text
1，通过类型字面量显式地进行值调用和表达式调用，编译器不会做自动转换，会进行严格的方法集检查
2，通过类型变量进行值调用和表达式调用
    值调用方式调用时编译器会进行自动转换
    表达式调用时编译器不会进行转换，会进行严格的方法集检查
```

## 4 组合和方法集

### 4.1 组合

struct：可以嵌入任意其他类型的字段，可以嵌套自身的指针类型的字段

### 4.2 组合的方法集

```text
若类型 S 包含 匿名字段 T，则 S 的方法集包含 T 的方法集
若类型 S 包含 匿名字段 *T，则 S 的方法集包含 T 和 *T 的方法集
*S 总是包含 T 和 *T 的方法集
```

## 5 函数类型

### 5.1 概念

```text
函数
    有名函数 `func FuncionName()`
        初始化一个函数字面量类型后将其赋值给一个函数名变量

    匿名函数 `func()`
        直接初始化一个函数字面量类型，只是没有绑定到一个具体变量上

函数类型
    函数字面量类型(未命名类型)，`func(InputTypeList)OutputTypeList`
        有名函数和匿名函数属于函数字面量类型
        不能定义自己方法

    函数命名类型(命名类型) `type NewFuncType FuncLiteral`
        NewFuncType 函数命名类型
        FuncLiteral 函数字面量类型 是 NewFuncType 的底层类型
        可以定义自己方法

函数签名，有名函数或匿名函数的字面量类型
    func (int, int) int

函数声明，函数名+函数签名
    函数签名 func (Input) Output
    函数声明 func FuncName(Input) Output
```

### 5.2 函数命名类型示例与注释

```go
package main

import (
    "fmt"
)

// 定义有名函数 add
// 函数名 add
// add 的函数签名是 func(int, int) int
// add 的字面量类型 func(int, int) int
// add 的类型是 函数字面量类型 func(int, int) int
// add 的函数声明与句 func add(int, int) int
func add(a, b int) int {
    return a + b
}

// 新定义函数类型 ADD
// ADD 底层类型是 函数字面量类型 func(int, int) int
type ADD func(int, int) int

func main() {
    // 定义匿名函数
    // 匿名函数不能独立存在，常作为函数参数、返回值，或者赋值给某个变量
    // 可以直接显式初始化
    // 匿名函数的类型是 函数字面量类型 func(int, int) int
    f := func(a, b int) int {
        return a + b
    }

    // add 和 ADD 的底层类型相同，并且 add 是字面量类型
    //所以 add 可直接赋值给 ADD 类型的变量 g
    var g ADD = add

    fmt.Println(g(1, 2))
    fmt.Println(f(1, 2))

    // 函数签名是 func(int, int) int
    fmt.Printf(f)
    fmt.Printf(add)
}

```

### 5.3 函数类型意义

```text
1，函数也是一种类型，可以在函数字面量类型的基础上定义一种命名函数类型
2，有名函数和匿名函数的函数签名与命名函数类型的底层类型相同，它们之间可以进行类型转换。
3，可以为有名函数类型添加方法，装饰设计
4，为有名函数类型添加方法
    使其与接口打通关系，使用接口的地方可以传递函数类型的变量，函数到接口的转换
```
