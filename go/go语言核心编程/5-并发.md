# 并发

## 1 并发基础

### 1.1 goroutine

并发执行体：goroutine，协程，用户态线程，轻量级线程，运行时管理

```go
package main

import (
    "time"
)

func sum() int {
    sum := 0
    for i := 0; i < 10000; i++ {
        sum += i
    }
    println(sum)
    time.Sleep(1 * time.Second)
}

func main(){
    // go + 有名函数
    go sum()

    // go + 匿名函数
    go func(){
        sum := 0
        for i := 0; i < 10000; i++ {
            sum += i
        }
        println(sum)
        time.Sleep(1 * time.Second)
    }

    time.Sleep(5 * time.Second)
}
```

#### 1.1.1 特性

```text
1，非阻塞
2，go 后的函数的返回值会被忽略
3，调度器不能保证多个 goroutine 的执行顺序
4，所有 goroutine 平等地被调度和执行
5，执行程序时，会单独为 main 创建一个 goroutine
6，Go 没有暴露 goroutine.id 给用户，不能在一个 goroutine 里显式地操作另一个 goroutine。
```

#### 1.1.2 GOMAXPROCS Goexit Gosched

```go
// GOMAXPROCS 设置或查询可以井发执行的 goroutine 数目
// 大于 1 为设置此值，否则为查询

runtime.GOMAXPROCS(5)
runtime.GOMAXPROCS(0)

// Goexit 结束当前 goroutine 的运行 --> defer

// Gosched 放弃当前调度执行机会，将当前 goroutine 放到队列中等待下次被调度
```

### 1.2 chan channel 通道

通道是 goroutine 之间通信和同步的重要组件。是 Go 通过通信来共享内存的载体。

```go
// 创建一个无缓冲的 chan，存放数据类型为 DataType
// len 和 cap 是 0
// 通信，两个 roroutine 同步
make(chan DataType)

// 十个缓冲
// len 是没有被读取的元素数，cap 是整个通道的容量
// 主要用于通信
// 削峰和增大吞吐量
make(chan DataType, 10)
```

```go
func main() {

    c := make(chan struct{})

    // go + 匿名函数
    go func(i chan struct{}) {
        sum := 0
        for i := 0; i < 10000; i++ {
            sum += i
        }
        println(sum)
        // 写通道
        c <- struct{}{}
    }(c)

    println("NumGoroutine=", runtime.NumGoroutine())
    println("Hello")

    // 读通道，通过通道可以同步等待
    <-c
}
```

### 1.3 操作不同状态的 chan 引发的行为

- panic 会导致 panic
  - 向已关闭的 chan 写数据。由写入者关闭
  - 关闭已关闭的 chan
- 阻塞 会导致当前 goroutine 阻塞
  - 向未初始化的 chan 读写数据，永久阻塞
  - 向缓冲区已满的 chan 写入数据
  - 读取无数据的 chan
- 非阻塞
  - 读取已关闭的 chan 不会阻塞，会返回该 chan 元素类型的**零值**，使用 comma, ok 语法判断 chan 有无关闭
  - 向有缓冲且未满的 chan 读写数据，不会阻塞

### 1.4 WaitGroup

WaitGroup: sync 提供了对 goroutine 同步的机制

### 1.5 select

多路监听多个通道

### 1.6 扇入(Fan in)扇出(Fan out)

扇入：将多路 chan 聚合到一个 chan 中处理，select
扇出：将一条 chan 分散到多条 chan 中处理，使用 go 关键字启动多个 goroutine

### 1.7 通知退出机制

读取已关闭的 chan 会返回该 chan 元素类型的零值。
关闭 select 坚挺的某个 chan 能使 select 感知到这种通知，然后进行相应处理。
context

## 2 并发范式，手段

### 2.1 生成器

统一的全局的生成器服务

```go
func GenerateA() chan int {
    // 带缓冲的生成器
    ch := make(chan int, 5)

    go func() {
        for {
            ch <- rand.Int()
        }
    }()
    return ch
}

func GenerateB() chan int {
    // 带缓冲的生成器
    ch := make(chan int, 5)

    go func() {
        for {
            ch <- rand.Int()
        }
    }()
    return ch
}

func GenerateInt() chan int {
    // 多个 goroutine 的增强型生成器
    ch := make(chan int, 10)
    go func() {
        for {
            select {
            case ch <- <-GenerateA():
            case ch <- <-GenerateB():
            }
        }
    }()
    return ch
}

func GenerateC(done chan struct{}) chan int {
    // 生成器自动退出

    ch := make(chan int)
    go func() {
    Label:
        for {
            // 通过 select 监听一个信号 chan 来确定是否停止生成
            select {
            case ch <- rand.Int():
            case <-done:
                break Label
            }
        }
        close(ch)
    }()
    return ch
}

func main() {
    ch_a := GenerateA()

    fmt.Println(<-ch_a)
    fmt.Println(<-ch_a)

    ch_int := GenerateInt()
    for i := 0; i < 15; i++ {
        fmt.Println(i)
        fmt.Println(<-ch_int)
    }

    done := make(chan struct{})
    ch_b := GenerateC(done)
    fmt.Println(<-ch_b)
    fmt.Println(<-ch_b)
    // 通过 close chan 发送一个通知给生成器
    close(done)
    for v := range ch_b {
        fmt.Println(v)
    }
}
```

### 2.2 管道

一个函数输入和输出参数是相同的 chan 类型，则该函数可以调用自身，形成调用链
多个具有相同参数类型的函数也能形成一个调用链，管道

```go
// chain 的输入输出参数均为 chan int 类型
// 将传入的 chan 内的数据统一加一
func chain(in chan int) chan int {
    out := make(chan int)
    go func() {
        for v := range in {
            out <- v + 1
        }
        close(out)
    }()
    return out
}

func main() {
    in := make(chan int)

    // 初始化数据
    go func() {
        for i := 0; i < 10; i++ {
            in <- i
        }
        close(in)
    }()

    // 执行三次
    out := chain((chain(chain(in))))
    for v := range out {
        fmt.Println(v)
    }
}
```

### 2.3 每个请求一个 goroutine
