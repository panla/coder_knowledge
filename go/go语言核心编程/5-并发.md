# 并发

[toc]

## 1 并发基础

### 1.1 goroutine

并发执行体：goroutine，协程，用户态线程，轻量级线程，运行时管理

```go
package main

import (
    "time"
)

func sum() int {
    sum := 0
    for i := 0; i < 10000; i++ {
        sum += i
    }
    println(sum)
    time.Sleep(1 * time.Second)
}

func main(){
    // go + 有名函数
    go sum()

    // go + 匿名函数
    go func(){
        sum := 0
        for i := 0; i < 10000; i++ {
            sum += i
        }
        println(sum)
        time.Sleep(1 * time.Second)
    }

    time.Sleep(5 * time.Second)
}
```

#### 1.1.1 特性

```text
1，非阻塞
2，go 后的函数的返回值会被忽略
3，调度器不能保证多个 goroutine 的执行顺序
4，所有 goroutine 平等地被调度和执行
5，执行程序时，会单独为 main 创建一个 goroutine
6，Go 没有暴露 goroutine.id 给用户，不能在一个 goroutine 里显式地操作另一个 goroutine。
```

#### 1.1.2 GOMAXPROCS Goexit Gosched

```go
// GOMAXPROCS 设置或查询可以井发执行的 goroutine 数目
// 大于 1 为设置此值，否则为查询

runtime.GOMAXPROCS(5)
runtime.GOMAXPROCS(0)

// Goexit 结束当前 goroutine 的运行 --> defer

// Gosched 放弃当前调度执行机会，将当前 goroutine 放到队列中等待下次被调度
```

### 1.2 chan channel 通道

通道是 goroutine 之间通信和同步的重要组件。是 Go 通过通信来共享内存的载体。

```go
// 创建一个无缓冲的 chan，存放数据类型为 DataType
// len 和 cap 是 0
// 通信，两个 roroutine 同步
make(chan DataType)

// 十个缓冲
// len 是没有被读取的元素数，cap 是整个通道的容量
// 主要用于通信
// 削峰和增大吞吐量
make(chan DataType, 10)
```

```go
func main() {

    c := make(chan struct{})

    // go + 匿名函数
    go func(i chan struct{}) {
        sum := 0
        for i := 0; i < 10000; i++ {
            sum += i
        }
        println(sum)
        // 写通道
        c <- struct{}{}
    }(c)

    println("NumGoroutine=", runtime.NumGoroutine())
    println("Hello")

    // 读通道，通过通道可以同步等待
    <-c
}
```

### 1.3 操作不同状态的 chan 引发的行为

- panic 会导致 panic
  - 向已关闭的 chan 写数据。由写入者关闭
  - 关闭已关闭的 chan
- 阻塞 会导致当前 goroutine 阻塞
  - 向未初始化的 chan 读写数据，永久阻塞
  - 向缓冲区已满的 chan 写入数据
  - 读取无数据的 chan
- 非阻塞
  - 读取已关闭的 chan 不会阻塞，会返回该 chan 元素类型的**零值**，使用 comma, ok 语法判断 chan 有无关闭
  - 向有缓冲且未满的 chan 读写数据，不会阻塞

### 1.4 WaitGroup

WaitGroup: sync 提供了对 goroutine 同步的机制

### 1.5 select

多路监听多个通道

### 1.6 扇入(Fan in)扇出(Fan out)

扇入：将多路 chan 聚合到一个 chan 中处理，select
扇出：将一条 chan 分散到多条 chan 中处理，使用 go 关键字启动多个 goroutine

### 1.7 通知退出机制

读取已关闭的 chan 会返回该 chan 元素类型的零值。
关闭 select 坚挺的某个 chan 能使 select 感知到这种通知，然后进行相应处理。
context

## 2 并发范式，手段

### 2.1 生成器

统一的全局的生成器服务

```go
func GenerateA() chan int {
    // 带缓冲的生成器
    ch := make(chan int, 5)

    go func() {
        for {
            ch <- rand.Int()
        }
    }()
    return ch
}

func GenerateB() chan int {
    // 带缓冲的生成器
    ch := make(chan int, 5)

    go func() {
        for {
            ch <- rand.Int()
        }
    }()
    return ch
}

func GenerateInt() chan int {
    // 多个 goroutine 的增强型生成器
    ch := make(chan int, 10)
    go func() {
        for {
            select {
            case ch <- <-GenerateA():
            case ch <- <-GenerateB():
            }
        }
    }()
    return ch
}

func GenerateC(done chan struct{}) chan int {
    // 生成器自动退出

    ch := make(chan int)
    go func() {
    Label:
        for {
            // 通过 select 监听一个信号 chan 来确定是否停止生成
            select {
            case ch <- rand.Int():
            case <-done:
                break Label
            }
        }
        close(ch)
    }()
    return ch
}

func main() {
    ch_a := GenerateA()

    fmt.Println(<-ch_a)
    fmt.Println(<-ch_a)

    ch_int := GenerateInt()
    for i := 0; i < 15; i++ {
        fmt.Println(i)
        fmt.Println(<-ch_int)
    }

    done := make(chan struct{})
    ch_b := GenerateC(done)
    fmt.Println(<-ch_b)
    fmt.Println(<-ch_b)
    // 通过 close chan 发送一个通知给生成器
    close(done)
    for v := range ch_b {
        fmt.Println(v)
    }
}
```

### 2.2 管道

一个函数输入和输出参数是相同的 chan 类型，则该函数可以调用自身，形成调用链
多个具有相同参数类型的函数也能形成一个调用链，管道

```go
// chain 的输入输出参数均为 chan int 类型
// 将传入的 chan 内的数据统一加一
func chain(in chan int) chan int {
    out := make(chan int)
    go func() {
        for v := range in {
            out <- v + 1
        }
        close(out)
    }()
    return out
}

func main() {
    in := make(chan int)

    // 初始化数据
    go func() {
        for i := 0; i < 10; i++ {
            in <- i
        }
        close(in)
    }()

    // 执行三次
    out := chain((chain(chain(in))))
    for v := range out {
        fmt.Println(v)
    }
}
```

### 2.3 每个请求一个 goroutine

### 2.4 固定 worker 工作池

构建固定数目的 goroutine 作为工作线程池

- 构建 goroutine
  - 初始化任务的 goroutine
  - 分发任务的 goroutine
  - 等待所有 worker 结束通知，然后关闭结果通道 goroutine
- 三个通道
  - 传递 task 的通道
  - 传递 task 结果的通道
  - 接收 worker 处理完任务后所发送通知的通道
- 流程
  - 构建 task 并发送到 task 通道
  - 启动若干工作线程，从 task 通道中获取任务，然后写入结果通道，如果任务通道被关闭，则向收集结果的 goroutine 发送通知
  - 收集结果的 goroutine 接收到所有 task 已经处理完毕的信号后，主动关闭结果通道
  - 读取，统计结果

### 2.5 future

一个流程多个子调用，子调用间无依赖

future 基本工作原理

- 使用 chan 作为函数参数
- 启动 goroutine 调用函数
- 通过 chan 传入参数
- 执行其他
- 通过 chan 异步获取结果

## 3 context

多个 goroutine 被平等平行调度
多个 goroutine 协作工作涉及 通信，同步，通知，退出

通信：chan 是 goroutine 之间通信的基础，数据通道
同步：不带缓冲的 chan，sync.WaitGroup 提供同步机制
通知：管理，控制流数据
退出：借助 chan 和 select 的广播机制

### 3.1 context 目的与作用

context 提供把 XXX 传递给整个 goroutine 调用树上的每一个 goroutine

- 退出通知机制：把通知
- 元数据传递：把数据

### 3.2 基本数据结构

root 节点：第一个创建 Context 的 goroutine，创建一个实现 Context 接口的具体对象，并把该对象作为参数传递给新拉起的 goroutine。
下游的 goroutine 继续封装，传递。
通过位于 root 的 Context 对象，遍历整个 调用树。
通知和消息通过 root 节点传递出去，实现上下游消息传递
