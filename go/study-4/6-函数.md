# 函数

## 0

命名类型的方法，其本质是一个函数，类型方法时 Go 面向对象的实现基础。

接口的底层通过 指针和函数将接口和接口实例连接起来

并发语句 go + 函数

函数也是一种类型，可以作为参数，可以作为返回值，可以直接调用

## 1 参数

### 1.1 无参数

```go
func function() {
    fmt.Println("pandora")
}
```

### 1.2 不定参数

- 除空接口外，不定参数类型需要相同
- 不定参数在参数顺序的最后一个
- 不定参数名 相当于切片
- 切片作为参数传递给函数时，需要传 (slice ...int)
- 数组不能作为实参传递给函数中的不定参数

```go
func function(a int, args ...int) (result int) {
    result += a
    for _, arg := range args {
        result += arg
    }
    return
}

function(1, 2, 3, 4, 5, 6)

array := []int{1, 2, 3, 4}
function(1, array...)
```

### 1.3 任意类型不定参数

```go
func function(args ...interface{}) {
    //
}
```

## 2 返回值

### 2.1 命名返回值

```go
// 不需要特别地声明 x
func function() (x int) {
    x = 10
    return
}
```

### 2.2 多值返回

```go
func function() (int, int) {
    x := 10
    y := 20
    return x, y
}
```

### 2.3 无返回

```go
func function() {
    fmt.Println("pandora")
}
```

## 3 不支持

- 不支持默认值参数
- 不支持函数重载
- 不支持命名函数嵌套定义

## 4 函数类型-函数签名，匿名函数

函数类型-函数签名: 函数定义首行去掉 函数名，参数名，{

可以使用 type 定义函数类型，作为函数的参数或返回值

```go
func add(a, b int) (c int) {
    c = a + b
    return c
}

var f func(int, int) int
```

### 4.1 匿名函数

#### 4.1.1 匿名函数被赋值给函数变量

```go
var sum = func(a, b int) int {
    return a + b
}
```

#### 4.1.2 匿名函数作为返回值

```go
func function(){
    return func(a, b int) int {
        return a + b
    }
}

f := function()
r := f(1, 2)
// r = 3
```

#### 4.1.3 匿名函数被直接调用 defer

```go
func main() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err)
        }
    }()
}
```

#### 4.1.4 匿名函数作为实参

```go
func function(f func(int, int) int, a, b, int) int {
    return f(a, b)
}

function(func(x, y int) int {
    return x + y
}, 1, 2)
// 3
```

## 4.2 闭包

闭包由函数及其引用环境组合成

一般通过在匿名函数中引用外部函数的局部变量或包全局变量构成

目的是减少全局变量，但会彼此干扰

- 如果一个函数调用返回的闭包引用修改了局部变量，同一个返回使用同一个局部变量，会受影响，不同返回使用不同的局部变量不受影响
- 如果一个函数调用返回的闭包引用修改了全局变量，每次调用都会影响全局变量。 XXX 不好

```go
func function(a int) func(i int) int {
    return func(i int) int {
        fmt.Println(&a, a)
        a += i
        return a
    }
}

func main() {

    f := function(1)
    g := function(1)

    // 2 4. 1 + 1 = 2, 2 + 2 = 4
    // 调用的 f 引用了相同的副本
    fmt.Println(f(1))
    fmt.Println(f(2))

    // f 与 g 引用不同的副本
    fmt.Println(g(1))
    fmt.Println(g(2))
}
```
