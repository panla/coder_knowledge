# 函数

## 4

### 4.1 匿名函数

#### 4.1.1 匿名函数被赋值给函数变量

```go
var sum = func(a, b int) int {
    return a + b
}
```

#### 4.1.2 匿名函数作为返回值

```go
func function(){
    return func(a, b int) int {
        return a + b
    }
}

f := function()
r := f(1, 2)
// r = 3
```

#### 4.1.3 匿名函数被直接调用 defer

```go
func main() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err)
        }
    }()
}
```

#### 4.1.4 匿名函数作为实参

```go
func function(f func(int, int) int, a, b, int) int {
    return f(a, b)
}

function(func(x, y int) int {
    return x + y
}, 1, 2)
// 3
```

## 4.2 闭包

闭包由函数及其引用环境组合成

一般通过在匿名函数中引用外部函数的局部变量或包全局变量构成

目的是减少全局变量，但会彼此干扰

- 如果一个函数调用返回的闭包引用修改了局部变量，同一个返回使用同一个局部变量，会受影响，不同返回使用不同的局部变量不受影响
- 如果一个函数调用返回的闭包引用修改了全局变量，每次调用都会影响全局变量。 XXX 不好

```go
func function(a int) func(i int) int {
    return func(i int) int {
        fmt.Println(&a, a)
        a += i
        return a
    }
}

func main() {

    f := function(1)
    g := function(1)

    // 2 4. 1 + 1 = 2, 2 + 2 = 4
    // 调用的 f 引用了相同的副本
    fmt.Println(f(1))
    fmt.Println(f(2))

    // f 与 g 引用不同的副本
    fmt.Println(g(1))
    fmt.Println(g(2))
}
```
