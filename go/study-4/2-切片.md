# 切片

[toc]

## 0

这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小

元数据包括

- 底层数组的指针
- 切片访问的元素的个数，长度
- 切片允许增长到的元素个数，指底层数组从 切片第一个元素 到 底层数组最后的元素 的数量

## 1 声明与初始化

### 1.1 make

```go
slice := make([]string, 5, 10)

// 长度=5，容量=10 的字符串切片
// 访问 index < len 的元素
```

### 1.2 用切片字面量声明切片

```go
slice := []string{"Red", "Green", "Blue", "Yellow"}
```

### 1.3 通过索引声明切片

```go
slice := []string{99: "pandora"}

// len = cap = 100
```

### 1.4 空切片

```go
var slice []int

slice := make([]int, 0)

slice := []int{}
```

### 1.5 array -> slice

```go
array := [5]int{10, 11, 12, 13, 14}

s1 := array[:]
// [10 11 12 13 14]

s2 := array[1:]
// [11 12 13 14]

s3 := array[:3]
// [10 11 12] 顾头不顾尾

s4 := array[1:3]
// [11 12]
```

### 1.6 slice -> slice

```go
slice := []int{10, 11, 12, 13, 14, 15}

new_slice := slice[:3]
```

## 2 Use Slice

### 2.1 get update

```go
slice := []int{10, 11, 12, 13, 14, 15}

slice[0]
// 10

new_slice := slice[:3]

new_slice[0] = 11

// 底层数组被修改
```

### 2.2 append

切片扩容后产生新数组, len=cap的切片使用 append 将产生新的底层数组，可以利用这个防止修改

```go

slice := []int{10, 20, 30, 40, 50}
// [10 20 30 40 50]
newSlice := slice[1:3]
// [20 30] 40 50

newSlice = append(newSlice, 60)
// [20 30 60]
// 如果已定义 newSlice 则用 = ，表示重新赋值
// 如果未定义，则用 :=

// slice slice 和 newSlice 共享底层数组，也发生了变化
// [10 20 30 60 50]

fmt.Printf("len %d cap %d\n", len(slice), cap(slice))
```

```go
a := []int{1, 2}
b := []int{3, 4}

c := append(a, b...)
// [1 2 3 4]
```

### 2.3 利用索引

```go
source := []string{"a", "b", "c", "d", "e"}

slice := source[2:3:4]
// [c] d
// 第一个值为开始的元素的 index, 第二个值为开始index+元素个数(长度)，第三个值为开始index+希望包含的个数(容量)
// 长度为 1，容量为 2
```

### 2.4 传递

比如在函数传参，复制切片时数据在底层数组中，只会复制切片本身

## 3 循环

### 3.1 range

range 创建了每个元素的副本，而非其引用，不可直接使用 指针

```go
source := []string{"a", "b", "c", "d", "e"}

for index, value := range(slice){
    //
}

for index, value := range slice {
    //
}
```

### 3.2 for

```go
source := []string{"a", "b", "c", "d", "e"}

for index := 0; index < len(source); index++ {
    //
}
```
