# 接口

- 接口是一个编程规约，也是一组方法签名的集合
- 接口是没有具体实现辑的，也不能定义字段
- `一个具体类型实现接口不需要在语法上显式地声明，只要具体类型的方法集是接口方法集的超集，就代表该类型实现了接口`

```text
实例变量，变量值，变量类型，方法
接口变量，变量值，变量类型
空接口，
```

[toc]

## 1 基本概念

### 1.1 接口声明

```go
// 接口字面量类型
interface {
    Read(p []byte) {n int, err error}
    Write(p []byte) {n int, err error}
}

// 接口命名类型
type Reader interface {
    // 接口命名类型，内含 方法声明
    Read(p []byte) {n int, err error}
}

type Writer interface {
    Write(p []byte) {n int, err error}
}

// 混合
type ReaderWriter interface {
    // 接口类型匿名字段(接口内嵌入其他接口)
    Reader

    // 方法声明=方法名+方法签名
    Write(p []byte) {n int, err error}
}
```

### 1.2 接口初始化，接口方法调用，接口动态类型，静态类型

### 1.2.1 接口初始化

接口绑定具体类型的实例的过程称为接口初始化

```text
要求赋值者的方法集是接口变量的方法集的超集
等号右边的方法集是左边接口变量的方法集的超集

实例赋值接口变量
    如果实例的方法集是接口的方法集的超集，则该具体类型实现了接口，
    可以把该实例直接赋值给接口类型的变量
    初始化后，调用接口的方法就相当于调用接口绑定的具体类型的方法

接口变量赋值给接口变量
    已经初始化的接口类型变量a直接赋值给另一种接口变量b，要求b的方法集是a的方法集的子集
```

#### 1.2.2 接口方法调用

初始化后，会使用具体类型的方法指针初始化接口变量
间接调用实例的方法，运行时调用

#### 1.2.2 接口动态类型，静态类型

接口绑定的具体实例的类型称为动态类型
定义接口时，接口的类型为静态类型，是 接口的方法签名集合
大的赋值给小的，超集赋值给子集

## 2 接口运算

类型断言
类型查询，检查运行时的接口类型

### 2.1 类型断言

```text
i.(TypeName)

i: 接口变量
TypeName:
    接口类型: 判断 i 绑定的实例类型是否实现了 TypeName 接口
    具体类型名: 判断判断 i 绑定的实例类型是否是 TypeName

o := i.(TypeName)
o 的类型是 TypeName
TypeName:
    接口类型: o 底层绑定的具体类型实例是 i 绑定的实例值的副本
    具体类型名: o 的值是 i 绑定的实例值的副本
```

### 2.2 类型查询

```text
switch v := i.(TypeName) {
    case type_1:
        xxx
    case type_2:
        yyy
    default:
        zzz
}
```

#### 2.2.1 语义分析

```text
查询一个接口变量底层绑定的底层变量的具体类型是什么
查询一个接口变量绑定的底层变量是否还实现了其他接口

i 是接口类型变量
case 语句后，可以是 非接口类型名或接口类型名
    接口类型名：v 的类型是接口类型，v 底层绑定的具体类型实例是 i 绑定的实例值的副本
    具体类型名：v 是该具体类型变量，v 的值是 i 绑定的实例值的副本
```

### 2.3 接口优点，使用形式

解耦
实现泛型，使用空接口作为函数或方法用在需要泛型的场景中

- struct 内嵌字段
- 其他接口内嵌字段
- 函数或方法形参
- 函数或方法返回值

## 3 空接口

### 3.1 概念与作用

没有任何方法的接口 我们称之为空接 。空接口表示为 `interface｛}`

泛型，如果一个函数需要接收任意类型的参数，参数类型可以是**空接口**这是弥补没有泛型的一种手段
反射，反射库就是将相关具体的类型转换并赋值给空接口后才去处理
