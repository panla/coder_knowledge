# 基础

[toc]

## 3 词法单元

标识符，操作符，分隔符

### 3.1 关键字 标识符

```text
定义包名 package
导入包名 import
声明常量 const
声明变量 var
定义函数 func
延迟执行 defer
并发语法 go
函数返回 return
```

```text
定义结构类型 struct
定义接口类型 interface
声明或创建map map
声明或创建chan chan
```

```text
流程分支 if else
循环 for range break continue
switch select type case default fallthrough
goto
```

### 3.2 内置类型 标识符

```text
整型，浮点型，复数，字符，字符串，接口，布尔
```

### 3.2 内置函数 标识符

```text
make new len cap append copy delete panic recover close complex real image Print Println
```

### 3.3 常量与空白 标识符

```text
true, false
iota
nil
_
```

### 3.4 操作符

```text
+ - * / %
& | ^ &^ >> <<
:= = += -= *= /= %= &= |= ^= &^= >>= <<=
> >= < <= == !=
() {} []
&& || !
++ --
```

## 4 变量和常量

高级语言通过**一个标识符来绑定一块特定的内存**，后续对特定内存的操作都可以使用该标识符来代替，
把对地址的操作和引用变为对变量的操作是编程领域的巨大进步

### 4.1 变量

使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时的类型决定，该内存地址存放的内容可变。

```go
var varName dataType [ = value]
// 关键字 变量名称标识符 基本类型 初始值
// 如果无初始值，则初始化为类型的零值
// 声明后立即分配空间

var name string = "pandora"

// 短类型声明，只存在于函数内，此时自动进行类型推断
var name := "pandora"

// 匿名变量
```

注意

```text
函数外的每个语句都需要以关键字开始
:= 不能在函数外
变量不能重复声明
_ 匿名变量
```

### 4.2 常量

使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时的类型决定，该内存地址存放的内容不可变。

分为 布尔型常量，字符型常量，数值型常量

预声明标识符 **iota** 用在常量声明中，其初始值为 0，一组多个常量同时声明时**其值逐行增加**，自增的枚举变量，专门用来初始化常量

```go
const (
    c0 = iota  // co = 0
    c1 = iota  // c1 = 1
    c2 = iota  // c2 = 2
)

const (
    d0 = iota
    d1
    d2
)
```

## 5 基本数据类型-预声明简单类型

### 5.1 布尔类型 bool

```text
true false
比较表达式和逻辑表达式的结果都是布尔类型数据
```

### 5.2 整型

```text
byte
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64
uintptr

byte 是 uint8 的别名
```

### 5.3 浮点型

```text
float32 float64

浮点数字面量被自动推断为 float64
应用 math 来比较
```

### 5.4 复数

```text
complex64 comples128
```

### 5.5 字符 rune

rune 是 int32 的别名，byte 是 uint 的别名

### 5.6 字符串 string

```go
var name = "pandora"

address := "北京市"

var location string
location = "南京市"

var sn string = "123455"

// 转为字节数组
name_ := []byte(name)
// 转为Unicode的字符数组
address_ := []rune(address)
```

```text
1，字符串是常量，可以通过索引访问
2，字符串转为切片要慎用，每转换一次都会复制内容
3，字符串末尾不含 NULL 字符
4，字符串类型底层实现是一个二元的数据结构，一个是指针指向字节数组的起点，另一个是长度
5，基于字符串创建的切片和原字符串指向相同的底层字符数组，不能修改，对字符串的切片操作返回的仍是字符串
```

### 5.7 错误类型 error

## 6 基本数据类型-复合数据类型

指针(pointer)，数组(array)，切片(slice)，字典(map)，通道(channel)，结构(struct)，接口(interface)

### 6.1 指针

指针类型声明为 `*T`

通过在变量名前加 & 获取变量的地址

`*T` 出现在 = 左边表示**指针声明**，出现在 = 右边表示**取指针指向的值**

```go
var name = "pandora"
p := &name  // *p 和 name 的值都是 pandora

// p 0xc00018a050
// *p pandora
// name pandora
```

### 6.2 数组

```go
var names [3]string
ages := [...]int8{12, 13, 14, 15}

// 指定长度和初始化值
a := [3]{1, 2, 3}
// 不指定长度，由初始化列表数量来确定长度
b := [...]int{1, 2, 3}
```

- 创建完，确定长度，不可追加
- 数组是值类型，值拷贝传递
- 数组长度是数组类型的组成部分，[10]int [20]int 表示不同的类型。
- 可以根据数组创建切片

### 6.3 切片 slice

变长数组，数据结构中有指向数组的指针，是引用类型

三个元素：指向底层数组的指针、切片的元素数量和底层数组的容量

通过数组创建切片

```text
长度 len()
容量 cap()
追加 append()
复制 copy()
```

```go
ages := [...]{10, 11, 12, 13, 14, 15, 16, 17}
// [10 11 12 13 14 15 16 17]

ages_1 := ages[:]
// [10 11 12 13 14 15 16 17]

ages_2 := ages[1:5]
// [11 12 13 14]

ages_3 := ages[:5]
// [10 11 12 13 14]

ages_4 := ages[5:]
// [15 16 17]
```

通过 make 创建切片

```go
ages := make([]int8, 10)

names := make([]string, 10, 15)
```

字符串和切片

```go
names := "pandora"

names_1 := []byte(names)
names_2 := []rune(names)
```

### 6.4 map

`map[K]T` 是引用类型

创建map

```go
info := map[string]int{"a": 1, "b": 2}

// make(map[K]T)      容量使用默认值
// make(map[K]T, len) 使用指定长度

address := make(map[string]string)

location := make(map[string]int8, 10)
```

内置操作

```text
map[k]

delete(map, k)
```

### 6.5 struct

```go
type UserInfo struct {
    name string
    age int8
    address string
}
```

## 7 控制结构
