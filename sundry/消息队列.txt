
https://www.cnblogs.com/rsapaper/p/10382423.html

----------------------------------------------------------------------------------------

消息队列

解决应用解耦，异步消息，流量削峰等问题，在实现高性能，高可用，可伸缩，最终一致性架构中不可或缺

解耦
    将一个流程的上游和下游拆开，上游专注生产消息，下游专注处理消息
广播
    一个上游生产的消息被多个下游服务器处理
缓冲，削峰
    保护下游服务器根据实际的消费能力处理消息
异步
    上游发送完消息后，马上返回，下游异步处理


任务分发
远程调用


Kafka, Pulsar, RocketMQ, RabbitMQ, ZeroMQ

ActiveMQ
    Apache
    开源消息总线
    Java 开发
RabbitMQ
    Mozilla Pivotal
    开源消息队列系统
    erlang 开发
    AMQP的标准实现

    组成
        Broker
        Exchange    消息交换机，指定了消息按什么规则
        Queue       消息队列载体，每个消息会被投入到一个或多个队列
        Binding     绑定，把 Exchange 和 Queue 按照路由规则绑定
        RoutingKey  路由关键字，Exchange 根据关键字进行消息投递
        vHost       虚拟主机，一个 Broker 可以开设多个 vHost 用做不同用户的权限分离
        Producer    生产者
        Consumer    消费者
        Channel     消息通道，每个通道代表一个会话任务

        Producer ->>> Channel ->>> Exchange ---Binding--RoutingKey --->>> Queue

ZeroMQ
    Socket通信
    高性能，非持久化

Kafka
    Apache Linkin
    高吞吐量发布订阅系统，开源流处理平台

    持久层：按照分布式事务日志架构的 发布订阅队列

    组成
        Broker
        Topic           虚拟概念，一个集群可以有多个 Topic，作为一类消息的标识，一个生产者将消息发送到 Topic，
                            消息者通过订阅 Topic，获取分区消息
        Partition       物理概念，一个 Topic 对应一个或多个 Partition，新消息以追加方式写入分区，在同一个 Partition 消息有序
                            Kafka 通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读写
        Replicas        复制副本，一个分区有多个复制副本，master副本和follower副本
        Offset          偏移量，元数据，，重启继续消费数据
        Producer
        Consumer
        Consumer Group

    日志处理，大数据处理，高吞吐，低延迟

    一个集群多个 Broker，一个 Topic 多个 Partition
    如果某个 Topic 有 N 个 Partition，集群有 N+M 个 Broker，其中 N 个 Broker 存储该 Topic 的一个 Partition，剩下的 M 个 Broker
        不存储，
    应避免 Broker 数量少于某个 Topic Partition 数量，会造成不平衡

RocketMQ
    Apache 阿里

    Java 开发

    高吞吐，高可用，大规模分布式
    起源于 Kafka，优化消息的可传输和事务性

    交易，充值，流计算，日志

Apollo
    消息代理工具

--------------------------------------------------------------------------------------------

HiveMQ

RabbitMQ
    Python Celery

Kafka

EMQX
    MQTT 消息服务
    Websocket
    共享订阅
        在多订阅者间采用分组负载平衡方式派发消息


--------------------------------------------------------------------------------------------

解耦
    调用方 ----> 被调用方
    调用方 ----> 消息队列 ----> 消息服务 ----> 被调用方
    实现 调用防御被调用方的解耦

    ---------------------------------------------------------
    A ----> B/C/D
    此时如果 B C D 发生变化，需要 A 做对应的变化

    A ----> 消息队列 ----> 消息服务 ----> B/C/D
    此时如果 B C D 发生变化，在消息服务中做对应变化

异步

    用户注册 ----> 注册信息写入数据库 ----> 发送注册邮件 ----> 发送注册短信

    用户注册 ----> 注册信息写入数据库 ----> 发送注册邮件
                                    ----> 发送注册短信

    用户注册 ----> 注册信息写入数据库 ----> 消息队列
                                                    ----> 消息服务 ----> 发送注册邮件
                                                    ----> 消息服务 ----> 发送注册短信

流量削峰

消息通讯

日志处理

-----------

系统可用性，消息队列挂掉，消息重复消费，消息丢失，一致性问题
为啥用消息队列，别人用我能不用？为用而用

--------------------------------------------------------------------------------------------

消息不被重复消费，消息幂等性

产生重复消费
    消费完毕，消费者发送确认信息到消息队列，消息队列删除消息。
    网络传输等故障，确认信息没有到达消息队列，消息队列再次把消息分发给其他消费者

解决
    把 消息 做 Redis set 操作
    给消息分配全局 id，存入缓存

可靠性传输
    RabbitMQ
        生产者丢数据
            开启事务，吞吐下降
        消息队列丢数据
            开启持久化
        消费者丢数据
            手动确认

    Kafka
        生产者丢数据
            在生产者端
                设置 acks=all 保证 follwer 同步完成后才认为消息发送成功
                设置 retries=MAX 一旦写入失败，无线重试
        消息队列丢数据，数据未同步，Leader挂了
            replication.factor 大于 1 ，每个 Partition 至少两个副本
            min.insync.replicas 大于 1，一个 Leader 至少感知到一个 follwer 还可以连接
        消费者丢数据
            手动提交 Offset
