# PostgreSQL 字段类型

## 数字类型

PostgreSQL 没有无符号类型

| column | 字段 | 长度 | 范围 |
| :-: | :-: | :-: | :-: |
| smallint int2 | 小范围整数 | 2字节 | -32768 至 32767 |
| integer int4 | 整数 | 4字节 | -2147483648 至 2147483647 |
| bigint int8 | 大范围整数 | 8字节 | -9223372036854775808 至 9223372036854775807 |
| real | 6位十进制 | 4字节 | 6位十进制，可变精度，不精确 |
| double precision | 8字节 | 15位十进制，可变精度，不精确 |
| smallserial | int2 自增 | 2字节 | 1 至 32767 |
| serial | int4 自增 | 4字节 | 1 至 2147483647 |
| bigserial | int8 自增 | 8字节 | 1 至 9223372036854775807 |
| decimal | 自定义定点 |  | 最高小数点前131072位，以及小数点后16383位 |
| numeric | 自定义，速度慢 | numeric(precision, scale) | 最高小数点前131072位，以及小数点后16383位 |

```text
numeric(precision, scale)
  precision:    精度，有效位数总数
  scale:        刻度，小数部分数字位数
  显式指定时，最大精度为1000
decimal 与 numeric 等效

serial 和 bigserial 不能直接在 sqlalchemy 中指定
```

## 字符类型

| column | 描述 |
| :-: | :-: |
| varchar(n) | 变长 |
| char(n) | 变长，空白填充 |
| text | 变长，最大限制1GB |

## 时间，日期类型

| column | 字段 | 长度 |
| :-: | :-: | :-: |
| timestamp | 时间戳，包括日期时间，不带时区 | 8字节 |
| timestamp with time zone | 时间戳，包括日期时间，带时区 | 8字节 |
| timestamptz | 时间戳，包括日期时间，带时区 | 8字节 |
| date | 日期，年月日 | 4字节 |
| time | 时间，时分秒，不带时区 | 8字节 |
| time with time zone | 时间，时分秒，带时区 | 12字节 |
| interval | 时间间隔 | 16字节 |

timestamp 和 timestamptz 如何选择？？

### 时间日期类型结合 sqlalchemy

```python
created_at = db.Column(db.DateTime, server_default=text('CURRENT_TIMESTAMP'))
updated_at = db.Column(db.DateTime, server_default=text('CURRENT_TIMESTAMP'), onupdate=text('CURRENT_TIMESTAMP'))

# 没有 datetime 格式
# 没有 ON UPDATE，不能自动更新当前时间
# db.DateTime 和 db.TIMESTAMP 效果相同，都是 timestamp 格式
```

## JSON/JSONB 类型

| column | 描述 |
| :-: | :-: |
| JSON | 以文本形式存储，查询时需要解析 |
| JSONB | 以二进制形式存储，存储时需要解析 |

```text
json 和 jsonb数据类型接受几乎完全相同的值集合作为输入。
主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每次执行时必须重新解析该数据。
而jsonb数据被存储在一种分解好的二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。
但是 jsonb在处理时要快很多，因为不需要解析。

由于json类型存储的是输入文本的准确拷贝，其中可能会保留空格，键的顺序保留重复键值（处理函数会把最后的值当作有效值）。
相反，jsonb不保留空格、不保留对象键的顺序并且不保留重复的对象键。如果在输入中指定了重复的键，只有最后一个值会被保留。

jsonb也支持索引
josn 写快，读慢
josnb 写慢，读快
```

优选 **jsonb**

### JSON 类型 结合 sqlalchemy

```python
from sqlalchemy.dialects.postgresql import JSON, JOSNB


json_c = db.Column(JSON)
jsonb_c = db.Column(JSONB)

json_c = {"name": "pandora", "age": 12}
jsonb_c = {"name": "pandora", "age": 12}
```

## 数组类型

### 数组类型 sql

PostgreSQL为数组使用了一种从1开始的编号习惯

```sql
create table example (
    name varchar(100),
    price price[],
    schedule text[][],
    squares int4[3][3],
    authors _varchar NULL,
    -- authors varchar(20)[]
);

select authors[1] from example;
```

### 数组类型 结合 sqlalchemy

```python
from sqlalchemy.dialects.postgresql import ARRAY


# 一维
authors = db.Column(ARRAY(db.String(20)))

# 二维，dimensions = 维度数
author_ids = db.Column(ARRAY(db.Integer, dimensions=2))
```

### 问题

```text
a， array 与 ARRAY 的区别是什么？？
b， 如果传 ["a", "b,c", "d"]，在数据库里，{a,b,c,d}，是如何分割的？？
c， 能否不同类型共存，如 ["a", 1, "c"]
d， 索引序列要从 1 开始
```

## 范围类型

| column | 范围 |
| :-: | :-: |
| int4range | int4的范围 |
| int8range | int8的范围 |
| tsrange | 不带时区的时间戳的范围 |
| tstzrange | 带时区的时间戳范围 |
| daterange | date 的范围 |

### 范围类型 结合 sqlalchemy

```python
from datetime import datetime

from sqlalchemy.dialects.postgresql import TSRANGE
from sqlalchemy.dialects.postgresql import INT4RANGE
from psycopg2.extras import DateTimeRange
from psycopg2.extras import NumericRange


during = db.Column(TSRANGE())

obj.during = DateTimeRange(datetime(2020, 2, 1), datetime(2021, 2, 1))
# DateTimeRange(datetime.datetime(2020, 2, 1, 0, 0), datetime.datetime(2021, 2, 1, 0, 0), '[)')
# 左闭右开，保存为 ["2020-02-01 00:00:00","2021-02-01 00:00:00")

age_range = db.Column(INT4RANGE())

obj.age_range = NumericRange(1, 10)
# NumericRange(1, 10, '[)')
# 左闭右开，保存为 [1,10)
```
