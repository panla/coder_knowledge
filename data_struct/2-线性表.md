# 线性表

[toc]

## 线性表的定义

属于逻辑结构

### 线性表概念

```text
线性表是由相同数据类型的 n(n>=0) 个数据元素的有限序列，其中 n 为表长，当 n=0 时，线性表是空表

用 L 命名线性表，L = (a1, a2, a3 ...)

a1--a2--a3--a4--a5
```

关键词

- 唯一的 表头元素，表尾元素
- 前驱，后继
- 数据元素的位序
- 表长，空表

### 线性表特点

- 是序列，有限
- 相同数据类型
- 每个数据元素占据的空间一样大
- 数量有限

### 线性表操作

- 初始化
- 销毁
- 插入
- 删除
- 按值查找
- 按位查找
- 求表长
- 输出
- 判空

## 顺序表

顺序存储实现线性表，顺序表，放在一块连续的存储区

### 顺序表概念

属于存储结构方式

```text
把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中
元素之间的关系有存储单元的邻接关系来体现
```

### 顺序表特点

- 随机访问速度快，O(1) 访问到第个元素 i
- 存储密度高
- 扩展容量不方便
- 插入删除数据元素不方便

### 顺序表结构定义

- 数据区，元素集合
- 表头
- 容量
- 已有元素个数
- example

    ```text
    容量    8
    元素个数 4
    0       1234
    1       12345
    2       321
    3       33
    4
    5
    6
    7
    ```

- Python List

    ```text
    是元素外置动态顺序表，分离式结构

    list.append(x)  O(1)
    list.insert(x)  O(n)
    list.pop(x)     O(n)
    list.pop(x)     O(1)
    list.remove(x)  O(n)
    list[index]     O(1)
    list[-index]    O(1)
    list[index]     O(1)
    list.sort()     n * log(n)
    ```

### 列表实现顺序表的基本操作

```python
from typing import Any


class SeqList(object):
    def __init__(self, max_space: int = 30):
        """init
        
        max_space: 最大长度
        space_list: 申请列表
        length: 实际元素的个数
        """

        self.max_space = max_space
        self.space_list = max_space * [0]
        self.length = 0

    def append_item(self, item: Any):
        """末尾添加元素"""

        if self.length == self.max_space:
            print('表已满，不可添加元素')
        else:
            self.space_list[self.length] = item
            self.length += 1

    def print_item(self):
        """打印表"""

        for i in range(self.length):
            print(self.space_list[i])
        print('\n')

    def insert_by_index(self, index: int, data: Any):
        """插入指定位置"""

        if self.length == self.max_space:
            print('表已满')
        else:
            if index < 0 or index > self.length:
                print('index 不合法')
            else:
                i = self.length - 1
                while i >= index:
                    self.space_list[i + 1] = self.space_list[i]
                    i -= 1
                self.space_list[index] = data
                self.length += 1

    def delete_by_index(self, index: int):
        """按索引删除元素"""
        if self.length == 0:
            print('表为空')
        else:
            if index < 0 or index >= self.length:
                print('索引不合法')
            else:
                i = index
                while i < self.length:
                    self.space_list[i] = self.space_list[i + 1]
                self.length -= 1

    def search_by_data(self, data: Any):
        """按值搜索元素"""

        for i in range(self.length):
            if self.space_list[i] == data:
                break
            if i == self.length - 1:
                print('未找到')
                return -1
            else:
                print(f'已找到，索引为{i}')
                return i

    def delete_by_data(self, data: Any):
        """按值删除元素"""

        index = self.search_by_data(data)
        if index != -1:
            self.delete_by_index(index)
```

## 链表

```text
链式存储实现线性表，链式表
放在通过地址指针连接构造起来的一系列内存中
用一组任意的存储单元存储线性表的数据元素
不能随机存取，需要遍历
```

### 链表结点结构

- 数据域，存放数据
- 链接域，存放前驱后继的指针

## 单链表

### 单链表特点

动态结构，不需要预先分配空间，链接域占用额外空间,不能随机存取，需要遍历

head -> [data next_addr] [data next_addr] .. [data ^]

### 定义单链表操作

- [X] 判空
- [X] 求长
- [X] 遍历
- [X] 头插
- [X] 尾插
- [X] 指定位置插入
- [X] 按位搜索
- [X] 按值搜索
- [X] 头删
- [X] 尾删
- [X] 按位移除
- [X] 按值移除

```python
from typing import Any


class Node():
    def __init__(self, data=None, pre=None, next=None) -> None:
        self.data = data
        self.pre = pre
        self.next = next


class SingleLinkedList():
    def __init__(self) -> None:
        self.head = Node()
        self.count = 1

    def print_msg(self, msg):
        print('is_empty: ', self.is_empty())
        print('length: ', self.length())
        print('count: ', self.count)
        self.show()
        print(' ')
        print(str(msg).center(80, '='))

    def is_empty(self):
        return bool(not self.head.next)

    def length(self):
        cursor = self.head
        
        count = 0
        while cursor:
            cursor = cursor.next
            count += 1
        return count

    def show(self):
        cursor = self.head
        while cursor:
            print(cursor.data, end=', ')
            cursor = cursor.next

    def add(self, item):
        """头插"""

        node = Node(item)
        self.head.next = node
        self.count += 1

    def append(self, item):
        """尾插"""
        
        cursor = self.head
        node = Node(item)

        if not self.is_empty():
            while cursor and cursor.next:
                cursor = cursor.next
        cursor.next = node
        self.count += 1

    def insert(self, position, item):
        """指定位置插入"""

        cursor = self.head
        node = Node(item)

        if position > self.count:
            print('位置不合法')
            return

        for _ in range(position - 1):
            cursor = cursor.next

        # 先接尾，后接头
        node.next = cursor.next
        cursor.next = node
        self.count += 1

    def search_by_index(self, index: int):
        """按位搜索"""

        cursor = self.head
        for _ in range(index - 1):
            if cursor:
                cursor = cursor.next
        print(index, cursor.data)
        return cursor.data

    def search_by_value(self, value):
        """按值搜索"""

        cursor = self.head
        
        count = 0
        while cursor:
            if cursor.data == value:
                print(count, value)
                break
            else:
                cursor = cursor.next
                count += 1

    def remove(self):
        """头删"""

        if not self.is_empty():
            cursor = self.head
            if cursor.next.next:
                cursor.next = cursor.next.next
            else:
                cursor.next = None
            self.count -= 1

    def pop(self):
        """尾删"""

        if not self.is_empty():
            cursor = self.head
            while cursor.next and cursor.next.next:
                cursor = cursor.next
            cursor.next = None
            self.count -= 1

    def delete_by_index(self, index: int):
        if self.is_empty():
            print('空表')
        else:
            cursor = self.head
            pre = None

            for _ in range(index):
                pre = cursor
                cursor = cursor.next
            
            pre.next = cursor.next
            self.count -= 1

    def delete_by_value(self, item):
        """指定值删除"""

        cursor = self.head
        pre = None

        while cursor:
            if cursor.data == item:
                if cursor == self.head:
                    self.head = cursor.next
                else:
                    pre.next = cursor.next
                self.count -= 1
                break
            else:
                pre = cursor
                cursor = cursor.next
        else:
            print('no exists')


ssl = SingleLinkedList()
ssl.print_msg(1)

ssl.add(1)
ssl.print_msg('add')

ssl.append(2)
ssl.print_msg('append')

for i in range(3, 8):
    ssl.append(i)
ssl.print_msg('append many')

ssl.insert(3, 10)
ssl.print_msg('insert')

ssl.search_by_index(2)
ssl.print_msg('search_by_index')

ssl.search_by_value(4)
ssl.print_msg('search_by_value')

ssl.remove()
ssl.print_msg('remove')

ssl.pop()
ssl.print_msg('pop')

ssl.delete_by_index(2)
ssl.print_msg('delete_by_index')

ssl.delete_by_value(6)
ssl.print_msg('delete_by_value')

```

## 双链表

### 双链表概念

```text
两个链接域
[prior data next], [prior data next]
直接先驱结点的地址，直接后继结点的地址
a1.next = a2
a2.prior = a1
由头指针唯一确定
循环链表---双向循环链表
```

### 定义双链表操作

- [ ] 判空
- [X] 求长
- [ ] 遍历
- [ ] 头插
- [ ] 尾插
- [X] 指定位置插入
- [ ] 按位搜索
- [ ] 按值搜索
- [ ] 头删
- [ ] 尾删
- [ ] 指定位置删
- [ ] 按位移除
- [X] 按值移除

```python
from typing import Any


class DLNode(object):
    # 定义双链表结点
    def __init__(self, data):
        self.data = data
        self.prior = None
        self.next = None

        
class DoubleLinkedList(object):
    def __init__(self):
        self.head = DLNode(None)

    def length(self):
        """求表长"""

        p = self.head
        count = 0
        while p is not None:
            count += 1
            p = p.next
        return count

    def insert(self, pos: int, item: Any):
        """插入值

        pos: 位置
        item: 元素
        """

        p = self.head
        count = 0
        dl_node = DLNode(item)

        if pos >= self.length():
            return -1
        while count < pos:
            p = p.next
            count += 1

        dl_node.prior = p.prior
        p.prior.next = dl_node
        dl_node.next = p
        p.prior = dl_node
    
    def remove(self, item):
        """删除指定值

        a1 p a2

        p.prior.next = p.next
        p.next.prior = p.prior
        """

        p = self.head

        while p is not None and p.data != item:
            p = p.next

        if p.data == item:
            p.prior.next = p.next
            p.next.prior = p.prior

```

## 线性表的应用

### 线性表合并

```text
已知两个长度分别为 m 和 n 的升序序列，实现将它们合并为一个长度为 m + n 的升序序列，
并给出所写的算法时间复杂度

input:
    la = [1, 3, 5, 7]
    lb = [2, 4, 6, 8, 10, 11]
output:
    lc = [1, 2, 3, 4, 5, 6, 7, 8, 10, 11]
```

#### 顺序存储的线性表合并

利用列表实现顺序表的合并操作

时间复杂度：O(n + m)

```python
def merge(la: list, lb: list, lc: list) -> list:
    i = j = 0

    while i < len(la) and j < len(lb):
        if la[i] <= lb[j]:
            lc.append(la[i])
            i += 1
        else:
            lc.append(lb[j])
            j += 1
    if i >= len(la):
        lc.extend(lb[j:])
    else:
        lc.extend(la[i:])
    return lc
```

#### 链式存储的线性表合并

##### 循环遍历

##### 采摘结点

text

```text
1，定义两个遍历指针，Pa, Pb 分别指向La, Lb 的第一个节点
2，设置一个头指针Lc，作为新链表的头指针，定义一个Tail 指针记录链表的尾接电
3，比较Pa, Pb 结点的数据域的值，将数据小的连接在tail的后面，并修改数据小的指针，同时修改tail指针
4，重复 1-2-3，直到 Pa、Pb 为空，将剩余直接链接到tail的后面
```

code

```python
from typing import Any


class SLNode(object):
    def __init__(self, data):
        self.data = data
        self.next = None


class SingleLinkedList(object):
    def __init__(self):
        self.head = SLNode(None)

    def is_empty(self) -> bool:
        return bool(self.head)

    def append(self, item: Any):
        """尾插法"""

        p = self.head
        s = SLNode(item)

        if p is not None:
            self.head = s
        else:
            while p is not None:
                p = p.next
            p.next = s


def merge(la: SingleLinkedList, lb: SingleLinkedList, lc: SingleLinkedList) -> SingleLinkedList:
    pa = la.head
    pb = lb.head
    tail = lc.head

    while pa is not None and pb is not None:
        if pa.data <= pb.data:
            if lc.head is None:
                lc.head = pa
            else:
                tail.next = pa
            tail = pa
            pa = pa.next
        else:
            if lc.head is None:
                lc.head = pb
            else:
                tail.next = pb
            tail = pb
            pb = pb.next
        if pa is not None:
            tail.next = pa
        else:
            tail.next = pb

        return lc


def build_list():
    la = SingleLinkedList()
    lb = SingleLinkedList()
    for i in range(1, 8, 2):
        la.append(i)
    for i in range(2, 12, 2):
        lb.append(i)
    return la, lb


la, lb = build_list()
lc = SingleLinkedList()

lc = merge(la, lb, lc)
```
