# 线性表

[toc]

## 线性表的定义

属于逻辑结构

### 线性表概念

```text
线性表是由相同数据类型的 n(n>=0) 个数据元素的有限序列，其中 n 为表长，当 n=0 时，线性表是空表

用 L 命名线性表，L = (a1, a2, a3 ...)

a1--a2--a3--a4--a5
```

关键词

- 唯一的 表头元素，表尾元素
- 前驱，后继
- 数据元素的位序
- 表长，空表

### 线性表特点

- 是序列，有限
- 相同数据类型
- 每个数据元素占据的空间一样大
- 数量有限

### 线性表操作

- 初始化
- 销毁
- 插入
- 删除
- 按值查找
- 按位查找
- 求表长
- 输出
- 判空

## 顺序表

顺序存储实现线性表，顺序表，放在一块连续的存储区

### 顺序表概念

属于存储结构方式

```text
把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中
元素之间的关系有存储单元的邻接关系来体现
```

### 顺序表特点

- 随机访问速度快，O(1) 访问到第个元素 i
- 存储密度高
- 扩展容量不方便
- 插入删除数据元素不方便

### 顺序表结构定义

- 数据区，元素集合
- 表头
- 容量
- 已有元素个数
- example

    ```text
    容量    8
    元素个数 4
    0       1234
    1       12345
    2       321
    3       33
    4
    5
    6
    7
    ```

- Python List

    ```text
    是元素外置动态顺序表，分离式结构

    list.append(x)  O(1)
    list.insert(x)  O(n)
    list.pop(x)     O(n)
    list.pop(x)     O(1)
    list.remove(x)  O(n)
    list[index]     O(1)
    list[-index]    O(1)
    list[index]     O(1)
    list.sort()     n * log(n)
    ```

### 列表实现顺序表的基本操作

```python
from typing import Any


class SeqList(object):
    def __init__(self, max_space: int = 30):
        """init
        
        max_space: 最大长度
        space_list: 申请列表
        length: 实际元素的个数
        """

        self.max_space = max_space
        self.space_list = max_space * [0]
        self.length = 0

    def append_item(self, item: Any):
        """末尾添加元素"""

        if self.length == self.max_space:
            print('表已满，不可添加元素')
        else:
            self.space_list[self.length] = item
            self.length += 1

    def print_item(self):
        """打印表"""

        for i in range(self.length):
            print(self.space_list[i])
        print('\n')

    def insert_by_index(self, index: int, data: Any):
        """插入指定位置"""

        if self.length == self.max_space:
            print('表已满')
        else:
            if index < 0 or index > self.length:
                print('index 不合法')
            else:
                i = self.length - 1
                while i >= index:
                    self.space_list[i + 1] = self.space_list[i]
                    i -= 1
                self.space_list[index] = data
                self.length += 1

    def delete_by_index(self, index: int):
        """按索引删除元素"""
        if self.length == 0:
            print('表为空')
        else:
            if index < 0 or index >= self.length:
                print('索引不合法')
            else:
                i = index
                while i < self.length:
                    self.space_list[i] = self.space_list[i + 1]
                self.length -= 1

    def search_by_data(self, data: Any):
        """按值搜索元素"""

        for i in range(self.length):
            if self.space_list[i] == data:
                break
            if i == self.length - 1:
                print('未找到')
                return -1
            else:
                print(f'已找到，索引为{i}')
                return i

    def delete_by_data(self, data: Any):
        """按值删除元素"""

        index = self.search_by_data(data)
        if index != -1:
            self.delete_by_index(index)
```

## 链表

```text
链式存储实现线性表，链式表
放在通过地址指针连接构造起来的一系列内存中
用一组任意的存储单元存储线性表的数据元素
不能随机存取，需要遍历
```

### 链表结点结构

- 数据域，存放数据
- 链接域，存放前驱后继的指针

## 单链表

### 单链表特点

动态结构，不需要预先分配空间，链接域占用额外空间,不能随机存取，需要遍历

head -> [data next_addr] [data next_addr] .. [data ^]

### 定义单链表操作

```python
from typing import Any


class SLNode(object):
    # SingleLinkedNode
    # 定义单链表结点

    def __init__(self, data):
        """init

        data 数据域
        next 直接后继的指针
        """

        self.data = data
        self.next = None

        
class SingleLinkedList(object):
    def __init__(self):
        self.head = SLNode(None)

    def is_empty(self):
        if self.head is None:
            return True
        else:
            return False

    def length(self):
        """求表长"""

        p = self.head
        count = 0
        while p is not None:
            count += 1
            p = p.next
        return count

    def add_at_head(self, item):
        """头插法添加元素

        时间复杂度O(1)
        """

        sl_node = SLNode(item)
        sl_node.next = self.head
        self.head = sl_node

    def append_at_tail(self, item):
        """尾插法

        时间复杂度O(n)
        """

        p = self.head
        while p is not None:
            # 先移动到尾部
            p = p.next
        sl_node = SLNode(item)
        p.next = sl_node

    def show(self):
        """遍历
        
        时间复杂度O(n)
        """

        p = self.head
        while p is not None:
            print(p.data)
            p = p.next

    def search_by_pos(self, pos: int):
        """按序号查找

        pox 是位置，时间复杂度O(n)
        """

        p = self.head
        count = 1
        if pos < 1:
            return None
        else:
            while p is not None and count != pos:
                p = p.next
                count += 1

        # 查找成功返回 p，查找失败返回 None
        return p

    def search_by_data(self, data):
        """按值查找
        
        时间复杂度O(n)
        """

        p = self.head
        while p is not None and p.data != data:
            p = p.next
        if p.data == data:
            return p
        else:
            return None

    def insert_by_pos(self, pos: int, data: Any):
        """指定位置插入元素"""

        if pos == 0:
            self.add_at_head(data)
            return True

        p = self.head
        if p is None:
            return False

        count = 0
        sl_node = SLNode(data)

        if pos >= self.length():
            return -1

        while p is not None:
            count += 1
            if count > pos:
                sl_node.next = p.next
                p.next = sl_node
                return True
            else:
                p = p.next

    def remove_by_data(self, data: Any):
        """按值移除元素"""

        p = self.head
        if p.data == data:
            self.head = p.next
            return self.head
        else:
            pre = p
            p = p.next

        while p is not None:
            if p.data != data:
                # 第一次一定不等，所以会出现 pre
                pre = p
                # 记录 p 的前驱结点
                p = p.next
                # p 指针后移
            else:
                pre.next = p.next
                # 找到后修改指针
                return p
        if p is None:
            return None

    def search_max_item(self):
        """搜索最大元素"""

        p = self.head
        flag = p  # flag = p

        while p is not None:
            if flag.data < p.data:
                flag = p

            p = p.next
        return flag

```

## 双链表

### 双链表概念

```text
两个链接域
[prior data next], [prior data next]
直接先驱结点的地址，直接后继结点的地址
a1.next = a2
a2.prior = a1
由头指针唯一确定
循环链表---双向循环链表
```

### 定义双链表操作

```python
from typing import Any


class DLNode(object):
    # 定义双链表结点
    def __init__(self, data):
        self.data = data
        self.prior = None
        self.next = None

        
class DoubleLinkedList(object):
    def __init__(self):
        self.head = DLNode(None)

    def length(self):
        """求表长"""

        p = self.head
        count = 0
        while p is not None:
            count += 1
            p = p.next
        return count

    def insert(self, pos: int, item: Any):
        """插入值

        pos: 位置
        item: 元素
        """

        p = self.head
        count = 0
        dl_node = DLNode(item)

        if pos >= self.length():
            return -1
        while count < pos:
            p = p.next
            count += 1

        dl_node.prior = p.prior
        p.prior.next = dl_node
        dl_node.next = p
        p.prior = dl_node
    
    def remove(self, item):
        """删除指定值

        a1 p a2

        p.prior.next = p.next
        p.next.prior = p.prior
        """

        p = self.head

        while p is not None and p.data != item:
            p = p.next

        if p.data == item:
            p.prior.next = p.next
            p.next.prior = p.prior

```

## 线性表的应用

### 线性表合并

```text
已知两个长度分别为 m 和 n 的升序序列，实现将它们合并为一个长度为 m + n 的升序序列，
并给出所写的算法时间复杂度

input:
    la = [1, 3, 5, 7]
    lb = [2, 4, 6, 8, 10, 11]
output:
    lc = [1, 2, 3, 4, 5, 6, 7, 8, 10, 11]
```

#### 顺序存储的线性表合并

利用列表实现顺序表的合并操作

时间复杂度：O(n + m)

```python
def merge(la: list, lb: list, lc: list) -> list:
    i = j = 0

    while i < len(la) and j < len(lb):
        if la[i] <= lb[j]:
            lc.append(la[i])
            i += 1
        else:
            lc.append(lb[j])
            j += 1
    if i >= len(la):
        lc.extend(lb[j:])
    else:
        lc.extend(la[i:])
    return lc
```

#### 链式存储的线性表合并

##### 循环遍历

##### 采摘结点

text

```text
1，定义两个遍历指针，Pa, Pb 分别指向La, Lb 的第一个节点
2，设置一个头指针Lc，作为新链表的头指针，定义一个Tail 指针记录链表的尾接电
3，比较Pa, Pb 结点的数据域的值，将数据小的连接在tail的后面，并修改数据小的指针，同时修改tail指针
4，重复 1-2-3，直到 Pa、Pb 为空，将剩余直接链接到tail的后面
```

code

```python
from typing import Any


class SLNode(object):
    def __init__(self, data):
        self.data = data
        self.next = None


class SingleLinkedList(object):
    def __init__(self):
        self.head = SLNode(None)

    def is_empty(self) -> bool:
        return bool(self.head)

    def append(self, item: Any):
        """尾插法"""

        p = self.head
        s = SLNode(item)

        if p is not None:
            self.head = s
        else:
            while p is not None:
                p = p.next
            p.next = s


def merge(la: SingleLinkedList, lb: SingleLinkedList, lc: SingleLinkedList) -> SingleLinkedList:
    pa = la.head
    pb = lb.head
    tail = lc.head

    while pa is not None and pb is not None:
        if pa.data <= pb.data:
            if lc.head is None:
                lc.head = pa
            else:
                tail.next = pa
            tail = pa
            pa = pa.next
        else:
            if lc.head is None:
                lc.head = pb
            else:
                tail.next = pb
            tail = pb
            pb = pb.next
        if pa is not None:
            tail.next = pa
        else:
            tail.next = pb

        return lc


def build_list():
    la = SingleLinkedList()
    lb = SingleLinkedList()
    for i in range(1, 8, 2):
        la.append(i)
    for i in range(2, 12, 2):
        lb.append(i)
    return la, lb


la, lb = build_list()
lc = SingleLinkedList()

lc = merge(la, lb, lc)
```
