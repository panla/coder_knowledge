# 图

[toc]

图：Graph
逻辑结构属于图形结构
抽象的数学结构

## 图的性质和概念

### 图的定义和图示

图由两个集合构成，`G=<V, E>`, V(vertex)是**顶点**的非空有限集合，E(edge)是**顶点间的关系-边**的有限集合，边是顶点的无序或有序对集合

- 顶点：数据元素 Vi 称为顶点
- 边和弧，P(Vi, Vj)表示在顶点Vi,和Vj之间的有线相连，无向图则为边，有线图则为弧
- 边 无序偶对(Vi, Vj)，弧 有序偶对 `<Vi, Vj>`

无向图

```text
G = <V, E>
V = {V0, V1, V2, V3}
E = {(V0, V1), (V0, V3), (V1, V2), (V1, V4), (V2, V3), (V2, V4)}

无序对 (Vi, Vj), 顶点之间 Vi Vj 的线段称为无向边
所有边都没有方向，则为无向图
```

有向图

```text
G = <V, E>
V = {V0, V1, V2, V3}
E = {<V0, V1>, <V0, V2>, <V2, V3>, <V3, V0>}

有序对 <Vi, Vj> 从Vi到Vj的有向线段，有向弧，起点为弧尾，终点为弧头
若所有顶点之间的连线均为有方向，则为有向图
```

边上带权的图为网

```text
边的权
图的边/弧相关的数据信息称为权
```

无向完全图

```text
在无向图中，任意两个顶点之间都有一条边连接，则称为无向完全图，
n个顶点的无向完全图边数为n * (n - 1) / 2
```

有向完全图

```text
任意两个顶点之间都有方向互为相反的两条弧连接，则称该有向图为有向完全图
n个顶点的有向完全图边数为 n * (n - 1)
```

### 图中关系的术语

```text
邻接：表示两顶点之间的关系，若Vi 和 Vj 间有边相连接，则Vi Vj 互称邻接点
关联：边和顶点的关系，若Vi 和 Vj 间有边相连接，边 (Vi, Vj)关联于顶点Vi, Vj
顶点的度，入度，出度
    : 顶点V的度，关联于某定点V的边的数目
    入度，出度，有向图

顶点数n，边数e, 度的关系
所有顶点度数之和为 2 * e
```

### 图，路径相关的性质

```text
路径：连续的边构成的顶点序列
路径长度：非带权图的路径长度是指此路经上边的条数，带权图的路径长度是指路径上各弧的权值之和
回路：起点和终点相同的路径
简单路径：起点与终点可以相同，其余顶点均不相同的路径
简单回路：除路径起点和终点相同外，其余顶点均不相同的回路
有根图：存在一个顶点，到其他顶点均有路径
(强)连通图：任意两顶点均连通，叫连通图
子图：G=(V, E) G`=(V`, E`) 若 V` 属于 V, 且 E` 属于 E，则G`是G的子图

连通分量：无向图的极大连通子图称为G的连通分量
    该子图是连通子图(连通，子图),将G的任何不属于该子图中的顶点加入，子图不再连通
极小连通子图：在连通子图中，删去任意边后，不再连通

具有n个顶点的强连通图，至少n条边(环路)
具有n个顶点的连通图，至少n-1条边
```

### 图的抽象数据类型

- 顶点数，边数，顶点集合，边集合，加入顶点，加入边
- 获取边信息，度

图中要保存顶点的数据，顶点间的关系

## 顺序存储

### 邻接矩阵

表示顶点间邻接关系的矩阵

- 一个顶点表，记录各个顶点信息，[V0, V1, V3, ..., Vn]
- 一个邻接矩阵，表示各个顶点之间关系，n个顶点的图的邻接矩阵是一个 n 阶方阵

![alt 邻接矩阵](./images/图/邻接矩阵的定义.png)

#### 无向图的邻接矩阵

- 无向图的邻接矩阵是对称矩阵
- 顶点 i 的度 = 第 i 行(列)中 1 的个数，完全图的邻接矩阵中对角元素为0，其余为1

#### 有向图的邻接矩阵

![alt 有向图的邻接矩阵](./images/图/有向图的邻接矩阵.png)

行：元素之和 出度
列：元素之和 入度

#### 带权图、网的邻接矩阵

![alt 有向图的邻接矩阵](./images/图/带权图的邻接矩阵.png)

### 邻接矩阵的存储实现

- 确定总顶点数和总边数
- 构造顶点集合的列表
- 构造邻接矩阵的列表

```python
class GraphAX:
    def __init__(self, mat, verxs):
        # self.mat = [mat[i][:] for i in range(vnum)]  # 关系矩阵
        self.mat = mat  # 关系矩阵
        self.verxs = verxs  # 顶点表
        self.vnum = len(versx)  # 顶点数
```

#### 邻接矩阵优点

- 统计顶点的度
- 顶点不变，增删边时只需对应元素赋为1或0
- 判断任意两顶点之间是否相连
- 统计图中有多少边

#### 邻接矩阵缺点

- 不便于删除结点
- 浪费空间， O(n^2)
- 浪费时间，O(n^2)

## 顺序和链式存储结合

### 邻接表

- 为图中每个顶点建立单链表
- 第i个单链表中的节点表示依附于顶点Vi的边，有向图中指以Vi为尾的弧

![alt 邻接表的表示](./images/图/邻接表的表示.png)

```text
V0
    V0 - V1
    V0 - V3
V1
    V1 - V0
    V1 - V2
    V1 - V4
```

#### 邻接表特点

- 开辟空间大小与顶点数和边数有关
- 可以求顶点v的度
- 判定两顶点是否邻接
- 增删边
- 统计边数

#### 邻接表的定义与实现

第三方库，**networkx**

```python
class Anode:
    """边表结点"""

    def __init__(self, adjvex, weight=0, next=None):
        self.adjvex = adjvex  # 关联的边，顶点
        self.weight = weight  # 边上的权
        self.next = next  


class Vnode:
    """顶点表结点"""

    def __init__(self, data, head=None):
        self.data = data
        self.head = head  # 顶点表头指针


class Graph:
    def __init__(self):
        self.verts = []
        self.num_vertices = 0

    def add_vertex(self, key):
        """插入顶点元素"""

        vertex = Vnode(key)
        self.verts.append(vertex)
        self.num_vertices += 1
        return vertex

    def add_edge_operate(self, key):
        i = 0

        while i < len(self.verts):
            if key == self.verts[i].data:
                # 判断 key 是否在顶点表中
                v_node = self.verts[i]
                break
            i += 1
        if i == len(self.verts):
            # key 不在顶点表中

            v_node = self.add_vertex(key)
            # key 加入到 顶点表

        return v_node

    def add_edge(self, key_a, key_b, weight=None):
        
        v_a = self.add_edge_operate(key_a)
        v_b = self.add_edge_operate(key_b)

        # 找到顶点表中的下标索引
        v_b_index = self.verts.index(v_b)  

        # 生成边表结点，修改边表指针
        p = Anode(v_b_index, weight, v_a.head)

        v_a.head = p  # 修改顶点表指针
```

#### 无向图邻接表

- 不唯一
- n个结点，e条边的无向图，则其邻接表需n个头结点和2*e个表结点，适合稀疏图
- 顶点Vi的度是第i个边表中结点数

#### 有向图邻接表

邻接表，把以同一顶点为起点的弧存储在边表
逆邻接表，把以同一顶点为终点的弧存储在边表

- 顶点Vi的出度为第i个子单链表中结点数
- 顶点Vi的入度为整个邻接表中邻接点阈值是下标为i的结点个数
- 邻接表算出度，逆邻接表算入度

#### 网的邻接表

![alt 网的邻接表](./images/图/网的邻接表.png)

```text
V0
    V0 - V1 3
    V0 - V3 1
V1
    V1 - V0 3
    V1 - V2 5
    V1 - V4 1
```

## 图的基本运算

1 图的遍历

从连通图的某顶点出发，仅一次地访问图中所有的顶点
访问每个顶点的邻接点

- 起始点，按顶点列表存储顺序进行访问
- 避免重复，每个顶点设一个访问标志
- 深度优先，DFS, 广度优先，BFS

### 深度优先遍历图

```text
从图的某一顶点 V0，访问此顶点
依次从V0未被访问过的邻接点出发，深度优先遍历图，直至所有和V0连通的顶点都被访问到
若有未被访问到的顶点，则选择一个未被访问的顶点作为起点
重复，直至全部访问到
```

回退操作，非递归时，采用栈来辅助

#### 邻接矩阵深度优先遍历图

时间复杂度 O(n^2)

```python

```

#### 邻接表深度优先遍历图

时间复杂度 O(n+e) e 为边数/弧数

### 广度优先遍历图

```text
从图的某一顶点 V0，访问此顶点
依次从V0未被访问过的邻接点出发，广度优先遍历图，直至所有和V0连通的顶点都被访问到
若有未被访问到的顶点，则选择一个未被访问的顶点作为起点
重复，直至全部访问到
```

辅助数据结构为队列

#### 邻接矩阵广度优先遍历图

时间复杂度 O(n^2)

```python

```

#### 邻接表广度优先遍历图

时间复杂度 O(n+e)

```python

```

## 图的最小生成树

## 图的最短路径

## 拓扑排序

## 关键路径
